package semanticMarkup.ling.learn;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import opennlp.tools.sentdetect.SentenceDetectorME;
import opennlp.tools.sentdetect.SentenceModel;
import opennlp.tools.tokenize.Tokenizer;
import opennlp.tools.tokenize.TokenizerME;
import opennlp.tools.tokenize.TokenizerModel;
import opennlp.tools.util.InvalidFormatException;

import semanticMarkup.core.Treatment;
import semanticMarkup.knowledge.Stemmer;
import semanticMarkup.knowledge.lib.WordNetAPI;

public class UnsupervisedClauseMarkup implements ITerminologyLearner {
	// directory of /descriptions folder
	private String desDir = "";
	// directory of /characters folder
	private String chrDir = "";
	// learning mode
	private String learningMode = "";
	// prefix for all tables generated by this program
	private String prefix = "";
	// default general tag
	private String defaultGeneralTag = "general";
	// knowledge base
	private String knlgBase = "phenoscape";
	// tag length
	private int tagLength = 150;

	private String CHECKEDWORDS = ":"; // leading three words of sentences
	private int NUM_LEAD_WORDS = 3; // $N leading words
	private int SENTID = 0;
	private int DECISIONID = 0;
	private String PROPERNOUN = "propernouns"; // EOL

	private Map<String, String> numberRecords = new HashMap<String, String>(); // word->(p|s)
	private Map<String, String> singularRecords = new HashMap<String, String>();// word->singular
	private Map<String, String> POSRecords = new HashMap<String, String>(); // word->POSs
	//private Map<String, String> POSRecordsRECORDS = new HashMap<String, String>();
	private String NEWDESCRIPTION = ""; // record the index of sentences that
										// ends a description
	private Map<String, Integer> WORDS = new HashMap<String, Integer>();
	private Hashtable<String, String> PLURALS = new Hashtable<String, String>();

	private String NUMBER = "zero|one|ones|first|two|second|three|third|thirds|four|fourth|fourths|quarter|five|fifth|fifths|six|sixth|sixths|seven|seventh|sevenths|eight|eighths|eighth|nine|ninths|ninth|tenths|tenth";

	// the following two patterns are used in mySQL rlike
	private String PREFIX = "ab|ad|bi|deca|de|dis|di|dodeca|endo|end|e|hemi|hetero|hexa|homo|infra|inter|ir|macro|mega|meso|micro|mid|mono|multi|ob|octo|over|penta|poly|postero|post|ptero|pseudo|quadri|quinque|semi|sub|sur|syn|tetra|tri|uni|un|xero|[a-z0-9]+_";

	// 3_nerved, )_nerved, dealt with in subroutine
	private String SUFFIX = "er|est|fid|form|ish|less|like|ly|merous|most|shaped";

	// words in this list can not be treated as boundaries "to|a|b" etc.
	private String FORBIDDEN = "to|and|or|nor";

	private String PRONOUN = "all|each|every|some|few|individual|both|other";
	private String CHARACTER = "lengths|length|lengthed|width|widths|widthed|heights|height|character|characters|distribution|distributions|outline|outlines|profile|profiles|feature|features|form|forms|mechanism|mechanisms|nature|natures|shape|shapes|shaped|size|sizes|sized";
	private String PREPOSITION = "above|across|after|along|around|as|at|before|below|beneath|between|beyond|by|during|for|from|in|into|near|of|off|on|onto|out|outside|over|than|through|throughout|toward|towards|up|upward|with|without";
	private String TAGS = "";
	private String PLENDINGS = "[^aeiou]ies|i|ia|(x|ch|sh)es|ves|ices|ae|s";
	private String CLUSTERSTRING = "group|groups|clusters|cluster|arrays|array|series|fascicles|fascicle|pairs|pair|rows|number|numbers|\\d+";
	private String SUBSTRUCTURESTRING = "part|parts|area|areas|portion|portions";
	// grouped #may contain q but not the last m, unless it is followed by a p
	private String mptn = "((?:[mbq][,&]*)*(?:m|b|q(?=[pon])))";
	// grouped #must present, no q allowed
	private String nptn = "((?:[nop][,&]*)*[nop])";
	// grouped #when following a p, a b could be a q
	private String bptn = "([,;:\\\\.]*\\$|,*[bm]|(?<=[pon]),*q)"; 
	private String SEGANDORPTN = "(?:" + mptn + nptn + ")";
	private String ANDORPTN = "^(?:" + SEGANDORPTN + "[,&]+)*" + SEGANDORPTN
			+ bptn;
	private String IGNOREPTN = "(IGNOREPTN)"; // disabled
	// private String stop =
	// "state|page|fig|"+"a|about|above|across|after|along|also|although|amp|an|and|are|as|at|be|because|become|becomes|becoming|been|before|behind|being|beneath|between|beyond|but|by|ca|can|could|did|do|does|doing|done|during|for|from|had|has|have|hence|here|how|if|in|into|inside|inward|is|it|its|least|may|might|more|most|near|no|not|of|off|on|onto|or|out|outside|outward|over|should|so|than|that|the|then|there|these|this|those|throughout|to|toward|towards|under|up|upward|via|was|were|what|when|where|whereas|which|why|with|within|without|would";

	private String STOP = "state|page|fig|"
			+ "a|about|above|across|after|along|also|although|amp|an|and|are|as|at|be|because|become|becomes|becoming|been|before|behind|being|beneath|between|beyond|but|by|ca|can|could|did|do|does|doing|done|during|for|from|had|has|have|hence|here|how|if|in|into|inside|inward|is|it|its|least|may|might|more|most|near|no|not|of|off|on|onto|or|out|outside|outward|over|should|so|than|that|the|then|there|these|this|those|throughout|to|toward|towards|under|up|upward|via|was|were|what|when|where|whereas|which|why|with|within|without|would";
 
	// Data Holders
	// Table sentence
	private List<Sentence> sentenceTable = new LinkedList<Sentence>();
	
	// Table unknownwords
	private Map<String, String> unknownWordTable = new HashMap<String, String>();
	
	// Table wordpos
	private Map<WordPOSKey, WordPOSValue> wordPOSTable = new HashMap<WordPOSKey, WordPOSValue>();
	
	// Table heuristicnouns
	private Map<String, String> heuristicNounTable = new HashMap<String, String>();
	
	// Table singularPlural
	Set<SingularPluralPair> singularPluralTable = new HashSet<SingularPluralPair>();
	
	// Table modifier
	private Map<String, ModifierTableValue> modifierTable = new HashMap<String, ModifierTableValue>();
	
	// Table discounted
	private Map<DiscountedKey,String> discountedTable = new HashMap<DiscountedKey,String>();

	// Third Tools
	// WordNet
	private WordNetAPI myWN;
	// OpenNLP sentence detector
	private SentenceDetectorME mySentDetector;
	// OpenNLP tokenizer
	private Tokenizer myTokenizer;
	// JWI Stemmer
	// SimpleStemmer myStemmer;
	// Porter Stemmer
	private Stemmer myStemmer;

	// Msg Output Controllers
	// Control if output feedback on which step is in
	private boolean msg = false;
	// Control if output debug msg
	private boolean debug = false;
	// addHeuristicsNouns
	private boolean hn = true;
	
	
	private String NENDINGS = "\\w\\w(?:ist|sure)\\b";
	private String VENDINGS = "(ing)\\b";	
	private String SENDINGS = "(on|is|ex|ix|um|us|a)\\b";
	private String PENDINGS = "(ia|es|ices|i|ae)\\b";

	/**
	 * Constructor of UnsupervisedClauseMarkup class
	 * @param lm learning mode, can be "plain"
	 * @param p prefix
	 * @param wnDir directory of WordNet dictionary
	 */
	public UnsupervisedClauseMarkup(String lm, String p,
			String wnDir) {
		/**
		 * 1. Store 1) learning mode and 2) prefix
		 * 2. Get WordNet instance
		 * 3. Get OpenNLP sentence detector
		 * 4. Get OpenNLP tokenizer
		 * 5. Get JWI simple stemmer
		 */
		//System.out.println("Initialized:\n");

		this.chrDir = desDir.replaceAll("descriptions.*", "characters/");
		this.learningMode = lm;
		this.prefix = p;
		System.out.println(String.format("Learning Mode: %s", this.learningMode));
		System.out.println(String.format("Prefix: %s", this.prefix));

		// Get WordNetAPI instance
		try {
			myWN = new WordNetAPI(wnDir, false);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// Get OpenNLP sentence detector
		InputStream sentModelIn;
		try {
			sentModelIn = new FileInputStream("res/en-sent.bin");
			SentenceModel model = new SentenceModel(sentModelIn);
			this.mySentDetector = new SentenceDetectorME(model);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// Get OpenNLP tokenizer
		InputStream tokenModelIn;
		try {
			tokenModelIn = new FileInputStream("res/en-token.bin");
			TokenizerModel model = new TokenizerModel(tokenModelIn);
			this.myTokenizer = new TokenizerME(model);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// Get JWI simple stemmer
		//this.myStemmer = new SimpleStemmer();
		// Get Porter Stemmer
		this.myStemmer = new Stemmer();

	}

	// replace '.', '?', ';', ':', '!' within brackets by some special markers,
	// to avoid split within brackets during sentence segmentation
	public String hideMarksInBrackets(String text) {

		if (text == null || text == "") {
			return text;
		}

		String hide = "";
		int lRound = 0;
		int lSquare = 0;
		int lCurly = 0;

		for (int i = 0; i < text.length(); i++) {
			char c = text.charAt(i);
			switch (c) {
			case '(':
				lRound++;
				hide = hide + c;
				break;
			case ')':
				lRound--;
				hide = hide + c;
				break;
			case '[':
				lSquare++;
				hide = hide + c;
				break;
			case ']':
				lSquare--;
				hide = hide + c;
				break;
			case '{':
				lCurly++;
				hide = hide + c;
				break;
			case '}':
				lCurly--;
				hide = hide + c;
				break;
			default:
				if (lRound + lSquare + lCurly > 0) {
					if (c == '.') {
						hide = hide + "[DOT] ";
					} else if (c == '?') {
						hide = hide + "[QST] ";
					} else if (c == ';') {
						hide = hide + "[SQL] ";
					} else if (c == ':') {
						hide = hide + "[QLN] ";
					} else if (c == '!') {
						hide = hide + "[EXM] ";
					} else {
						hide = hide + c;
					}
				} else {
					hide = hide + c;
				}
			}
		}
		return hide;

	}

	public String restoreMarksInBrackets(String text) {

		if (text == null || text == "") {
			return text;
		}

		// restore "." from "[DOT]"
		// s#\[\s*DOT\s*\]#.#g;
		text = text.replaceAll("\\[\\s*DOT\\s*\\]", ".");
		// restore "?" from "[QST]"
		// s#\[\s*QST\s*\]#?#g;
		text = text.replaceAll("\\[\\s*QST\\s*\\]", "?");
		// restore ";" from "[SQL]"
		// s#\[\s*SQL\s*\]#;#g;
		text = text.replaceAll("\\[\\s*SQL\\s*\\]", ";");
		// restore ":" from "[QLN]"
		// s#\[\s*QLN\s*\]#:#g;
		text = text.replaceAll("\\[\\s*QLN\\s*\\]", ":");
		// restore "." from "[DOT]"
		// s#\[\s*EXM\s*\]#!#g;
		text = text.replaceAll("\\[\\s*EXM\\s*\\]", "!");

		return text;
	}

	public String handleText(String t) {

		if (t == null || t == "") {
			return t;
		}

		String text = t;

		//
		text = text.replaceAll("[\"']", "");

		// plano - to
		text = text.replaceAll("\\s*-\\s*to\\s+", " to ");

		//
		text = text.replaceAll("[-_]+shaped", "-shaped");

		// unhide <i>
		text = text.replaceAll("&lt;i&gt;", "<i>");

		// unhide </i>, these will be used by characterHeuristics to
		// collect taxon names
		text = text.replaceAll("&lt;/i&gt;", "</i>");

		// remove 2a. (key marks)
		text = text.replaceAll("^\\s*\\d+[a-z].\\s*", "");

		// this is not used any more, see perl code - Dongye
		// store text at this point in original
		// String original = text;

		// remove HTML entities
		text = text.replaceAll("&[;#\\w\\d]+;", " ");

		//
		text = text.replaceAll(" & ", " and ");

		// replace '.', '?', ';', ':', '!' within brackets by some
		// special markers, to avoid split within brackets during
		// sentence segmentation
		// System.out.println("Before Hide: "+text);
		text = hideMarksInBrackets(text);
		// System.out.println("After Hide: "+text+"\n");

		text = text.replaceAll("_", "-"); // _ to -
		text = text.replaceAll("", ""); //

		//
		// Matcher matcher1 = Pattern.compile("\\s+([:;\\.])").matcher(text);
		// if (matcher1.lookingAt()) {
		// text = text.replaceAll("\\s+([:;\\.])", matcher1.group(1));
		// }

		// absent ; => absent;
		while (true) {
			Matcher matcher1 = Pattern.compile("(^.*?)\\s+([:;\\.].*$)")
					.matcher(text);
			if (matcher1.lookingAt()) {
				text = matcher1.group(1) + matcher1.group(2);
			} else {
				break;
			}
		}

		// absent;blade => absent; blade
		while (true) {
			Matcher matcher2 = Pattern.compile("(^.*?\\w)([:;\\.])(\\w.*$)")
					.matcher(text);
			if (matcher2.lookingAt()) {
				// text = text.replaceAll("^.*\\w[:;\\.]\\w.*",
				// matcher2.group(1)
				// + matcher2.group(2) + " " + matcher2.group(3));
				text = matcher2.group(1) + matcher2.group(2) + " "
						+ matcher2.group(3);
			} else {
				break;
			}
		}

		// 1 . 5 => 1.5
		while (true) {
			Matcher matcher3 = Pattern.compile("(^.*?\\d\\s*\\.)\\s+(\\d.*$)")
					.matcher(text);
			if (matcher3.lookingAt()) {
				text = matcher3.group(1) + matcher3.group(2);
			} else {
				break;
			}
		}

		// ###NOT necessary at all, done before in "absent ; => absent;"###
		// diam . =>diam.
		// Matcher matcher4 =
		// Pattern.compile("(\\sdiam)\\s+(\\.)").matcher(text);
		// if (matcher4.lookingAt()) {
		// text = text.replaceAll("\\sdiam\\s+\\.", matcher4.group(1)
		// + matcher4.group(2));
		// }

		// ca . =>ca.
		// Matcher matcher5 = Pattern.compile("(\\sca)\\s+(\\.)").matcher(text);
		// if (matcher5.lookingAt()) {
		// text = text.replaceAll("\\sca\\s+\\.",
		// matcher5.group(1) + matcher5.group(2));
		// }

		//
		while (true) {
			Matcher matcher6 = Pattern.compile(
					"(^.*\\d\\s+(cm|mm|dm|m)\\s*)\\.(\\s+[^A-Z].*$)").matcher(
					text);
			if (matcher6.lookingAt()) {
				text = matcher6.group(1) + "[DOT]" + matcher6.group(3);
			} else {
				break;
			}
		}

		return text;
	}

	// add space before and after all occurance of the regex in the string str
	public String addSpace(String str, String regex) {

		if (str == null || str == "" || regex == null || regex == "") {
			return str;
		}

		Matcher matcher = Pattern.compile("(^.*)(" + regex + ")(.*$)").matcher(
				str);
		if (matcher.lookingAt()) {
			str = addSpace(matcher.group(1), regex) + " " + matcher.group(2)
					+ " " + addSpace(matcher.group(3), regex);
			return str;
		} else {
			return str;
		}

	}

	public String handleSentence(String s) {

		if (s == null || s == "") {
			return s;
		}

		String sentence = s;

		// remove (.a.)
		sentence = sentence.replaceAll("\\([^()]*?[a-zA-Z][^()]*?\\)", " ");

		// remove [.a.]
		sentence = sentence.replaceAll("\\[[^\\]\\[]*?[a-zA-Z][^\\]\\[]*?\\]",
				" ");

		// remove {.a.}
		sentence = sentence.replaceAll("\\{[^{}]*?[a-zA-Z][^{}]*?\\}", " ");

		// to fix basi- and hypobranchial
		// s#\s*[-]+\s*([a-z])#_ $1#g;
		while (true) {
			Matcher matcher = Pattern.compile("(^.*?)\\s*[-]+\\s*([a-z].*$)")
					.matcher(sentence);
			if (matcher.lookingAt()) {
				sentence = matcher.group(1) + "_ " + matcher.group(2);
			} else {
				break;
			}
		}

		// add space around nonword char
		// s#(\W)# $1 #g;
		/*
		 * while (true) { Matcher matcher8
		 * =Pattern.compile("(^.*)(\\S\\W\\S)(.*$)").matcher( sentence); if
		 * (matcher8.lookingAt()) { //sentence = sentence.replaceAll("\\W", " "+
		 * // matcher8.group(1) // + " "); sentence = matcher8.group(1) + " "+
		 * matcher8.group(2) + " " + matcher8.group(3); } else { break; } } /
		 */
		sentence = this.addSpace(sentence, "\\W");

		// String [] substrings=
		// Pattern.compile("(\\W)").split(sentence);//matcher(sentence);
		// matcher8.replaceAll(" " + matcher8.group(1) + " ");
		// sentence="";
		// for (int i=0;i<substrings.length;i++) {
		// sentence=sentence+" "+substrings[i]+" ";
		// }

		// multiple spaces => 1 space
		// s#\s+# #g;
		sentence = sentence.replaceAll("\\s+", " ");

		// trim
		// s#^\s*##;
		sentence = sentence.replaceAll("^\\s*", "");

		// trim
		// s#\s*$##;
		sentence = sentence.replaceAll("\\s*$", "");

		// all to lower case
		sentence = sentence.toLowerCase();

		return sentence;
	}

	public boolean populateSents(List<Treatment> treatments) {
		System.out.println("Reading sentences:\n");
		//FileLoader fileLoader = new FileLoader(this.desDir);
		//if (!fileLoader.load())
		//	return false;

		//List<String> fileNameList = fileLoader.getFileNameList();
		//List<Integer> typeList = fileLoader.getTypeList();
		
		//List<String> textList = fileLoader.getTextList();
		
		//List<String>

		String text;
		//for (int i = 0; i < fileLoader.getCount(); i++) {
		for (int i=0;i<treatments.size();i++){
			//text = textList.get(i);
			Treatment tm = treatments.get(i);
			text = tm.getDescription();
			if (text != null) {
				// process this text
				text = this.handleText(text);
				// use Apache OpenNLP to do sentence segmentation
				String sentences[] = {};
				sentences = this.segmentSentence(text);

				Map<Integer, String> leadMap = new HashMap<Integer, String>();

				if (debug)
					System.out.println("Text: " + text);

				List<String> sentCopy = new LinkedList<String>();
				List<Integer> validIndex = new LinkedList<Integer>();
				int index = 0;
				// for each sentence, do some operations
				for (int j = 0; j < sentences.length; j++) {

					if (debug)
						System.out.println("Sentence " + j + ": "
								+ sentences[j]);

					// if(!/\w+/){next;}
					if (debug)
						System.out.println(sentences[j]);
					if (!sentences[j].matches("^.*\\w+.*$")) {
						continue;
					}
					validIndex.add(j);
					// restore ".", "?", ";", ":", "."
					sentences[j] = this.restoreMarksInBrackets(sentences[j]);
					// push(@sentcopy, $_);
					sentCopy.add(sentences[j]);

					// remove bracketed text from sentence (keep those in
					// originalsent); this step will not be able to remove
					// nested brackets, such as (petioles (2-)4-8 cm).
					// nested brackets will be removed after threedsent
					// step in POSTagger4StanfordParser.java
					sentences[j] = this.handleSentence(sentences[j]);

					getAllWords(sentences[j]);

					// first tokenize this sentence
					String tokens[] = this.myTokenizer.tokenize(sentences[j]);
					for (int i1 = 0; i1 < tokens.length; i1++) {
						this.unknownWordTable.put(tokens[i1], "unknown");
					}

					// Get the leading NUM_LEAD_WORDS words
					String lead = "";
					int minL = tokens.length > this.NUM_LEAD_WORDS ? this.NUM_LEAD_WORDS
							: tokens.length;
					for (int i2 = 0; i2 < minL; i2++) {
						lead = lead + tokens[i2] + " ";
					}
					lead = lead.replaceAll("\\s$", "");
					leadMap.put(j, lead);

					// Index increase by 1
					index++;

				}

				for (int j = 0; j < validIndex.size(); j++) {
					String line = sentences[validIndex.get(j)];
					String oline = sentCopy.get(validIndex.get(j));

					// handle line first
					// remove all ' to avoid escape problems
					// $line =~ s#'# #g;
					line.replaceAll("\'", " ");

					// then handle oline
					Matcher matcher = Pattern.compile(
							"(\\d)\\s*\\[\\s*DOT\\s*\\]\\s*(\\d)").matcher(
							oline);
					if (matcher.lookingAt()) {
						oline = oline.replaceAll(
								"(\\d)\\s*\\[\\s*DOT\\s*\\]\\s*(\\d)",
								matcher.group(1) + matcher.group(2));
					}

					// restore ".", "?", ";", ":", "."
					oline = this.restoreMarksInBrackets(oline);
					oline = oline.replaceAll("\'", " ");
					
					String lead = leadMap.get(j);
					
					String status = "";
			
					/**
					 	if(getnumber($words[0]) eq "p"){
					     $status = "start";
						}else{
					     $status = "normal";
					}
					
					if (this.getNumber(lead)
					
					if(getnumber($words[0]) eq "p"){
					     $status = "start";
						}else{
					     $status = "normal";
					}
					
					if (this.getNumber(lead)
 */
					if (oline.length() >= 2000) { // EOL
						oline = line;
					}

					this.sentenceTable.add(new Sentence(line, oline, lead,
							null, null, null, null));

					this.SENTID++;
				}
			}

		}
		System.out.println("Total sentences = " + SENTID);
		return true;
	}

	private void getAllWords(String sent) {
		// TODO Auto-generated method stub
		
	}

	String[] segmentSentence(String text) {
		String sentences[] = {};
		sentences = this.mySentDetector.sentDetect(text);
		return sentences;
	}

	public void addHeuristicsNouns() {
		// Get all sentences
		if (this.hn)
			System.out.println("Enter addHeuristicsNouns:\n");

		Set<String> nouns = this.getHeuristicsNouns();
		//nouns = this.characterHeuristics(nouns);
	}

	
	public Set<String> getHeuristicsNouns() {

		// Set of words
		Set<String> words = new HashSet<String>();
		
		// Set of nouns
		Set<String> nouns = new HashSet<String>();
		
		List<String> sents = new LinkedList<String> ();
		for (int i=0;i<this.sentenceTable.size();i++) {
			//String sent = this.sentenceTable.get(i).getSentence();
			String oSent = this.sentenceTable.get(i).getOriginalSentence();
			if (this.hn) {
				//if (!sent.equals(oSent)) {
				//System.out.println(sent+"\n");
				System.out.println(oSent+"\n");
				//}
			}
			sents.add(oSent);
			//if (this.d)
		}
		
		// Now we have original sentences in sents
		// Method addWords
		for (int i=0;i<sents.size();i++) {
			String noun = this.getPresentAbsentNouns(sents.get(i));
			if (!noun.equals("")) {
				nouns.add(noun);
			}
			
			// add words
			String[] tokens = this.myTokenizer.tokenize(sents.get(i));
			for (int j=0;j<tokens.length;j++) {
				String token = tokens[j];
				
				
				if (isWord(token)) {
					words.add(token);
				}
			}
		}
		
		// solve the problem: septa and septum are both s
		Iterator<String> nounsIterator= nouns.iterator();
		while (nounsIterator.hasNext()) {
			String oldNoun = nounsIterator.next();
			String newNoun = this.addHeuristicsNounsHelper(oldNoun, nouns);
			if (!newNoun.equals(oldNoun)) {
				nouns.remove(oldNoun);
				nouns.add(newNoun);
			}
		}
		
		// sort all words
		Map<String, List<String>> wordMap = new HashMap<String, List<String>>();
		Iterator<String> wordsIterator = words.iterator();
		while (wordsIterator.hasNext()) {
			String word = wordsIterator.next();
			String root = this.getRoot(word);
			if (wordMap.containsKey(root)) {
				List<String> wordList = wordMap.get(root);
				wordList.add(word);
			}
			else {
				List<String> wordList = new LinkedList<String>();
				wordList.add(word);
				wordMap.put(root, wordList);
			}
		}

		// find nouns
		// getnouns
		Iterator<String> wordsIterator2 = words.iterator();
		while (wordsIterator2.hasNext()) {
			String word = wordsIterator2.next();
			//word = "sgdsgsddcdfembraseure";
			if (word.matches("^.*"+this.NENDINGS)) {
				int dsgi=0;
				dsgi=90;
				nouns.add(word+"[s]");
				if (words.contains(word+"s")) {
					nouns.add(word+"s"+"[p]");
				}
				if (words.contains(word+"es")) {
					nouns.add(word+"es"+"[p]");
				}
			}
		}
		
		//Iterator<LinkedList> wordMapIterator = wordMap.i
		Iterator<Map.Entry<String, List<String>>> wordMapIterator = wordMap.entrySet().iterator();
		if (wordMapIterator.hasNext()) {
			Map.Entry<String, List<String>> wordMapEntry = wordMapIterator.next();
			List<String> wordList = wordMapEntry.getValue();
			
			// check if there is a word with Vending
			boolean hasVending = false;
			for (int i1=0;i1<wordList.size();i1++) {
				if (wordList.get(i1).matches("^.*"+this.VENDINGS)) {
					hasVending = true;
					break;
				}
			}
			
			// at least two words without verb endings
			if ((!hasVending) && (wordList.size()>1)) {
				for (int i=0;i<wordList.size();i++) {
					for (int j=i+1;j<wordList.size();j++) {
						String word1 = wordList.get(i);
						String word2 = wordList.get(j);
						List<String> pair = getSingularPluralPair(word1,
								word2);
						if (pair.size()==2) {
							String singular = pair.get(1);
							String plural = pair.get(2);
							nouns.add(singular+"[s]");
							nouns.add(plural+"[p]");
						}
					}
				}
			}	
		}

		return nouns;
	}
	
	public void characterHeuristics() {
		int sent_num = this.sentenceTable.size();
		
		Set<String> taxonNames = new HashSet<String>();
		Set<String> nouns = new HashSet<String>();
		
		// Noun rule 3
		Set<String> anouns = new HashSet<String>();
		Set<String> pnouns = new HashSet<String>();
		
		// Descriptor rule 2
		Set<String> descriptors = new HashSet<String>();
		
		for (int i=0;i<sent_num;i++) {
			
			// noun rule 0: taxon names
			Sentence sent = this.sentenceTable.get(i);
			String sentence = sent.getSentence();
			String oSentence = sent.getOriginalSentence();
			oSentence = this.trimString(oSentence);
			taxonNames = this.getTaxonNameNouns(oSentence);
			//if (taxonNames.size()>0) {
			//	Iterator<String> taxonNameIterator= taxonNames.iterator();
			//	while ()
			//}
			//$sentence =~ s#<\s*/?\s*i\s*>##g;
			//$originalsent =~ s#<\s*/?\s*i\s*>##g;
			sentence = sentence.replaceAll("<\\s*/?\\s*i\\s*>", "");
			oSentence = oSentence.replaceAll("\\s*/?\\s*i\\s*", "");
			// Update sentenceTable
			this.sentenceTable.get(i).setSentence(sentence);
			
			// noun rule 0.5: Meckle#s cartilage
			
			Set<String> nouns1 = this.getNounsMecklesCartilage(oSentence);
			nouns.addAll(nouns1);
			sentence = sentence.replaceAll("#", "");
			// Update sentenceTable
			this.sentenceTable.get(i).setSentence(sentence);	
			
			// noun rule 2: end of sentence nouns (a|an|the|some|any|this|that|those|these) noun$

			/**
			my $cp = $originalsent;
			while($cp =~ /(.*?)\b(a|an|the|some|any|this|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) +(\w+)\s*($|\(|\[|{|\b($PREPOSITION)\b)(.*)/){
				my $t = $3;
				$cp = $5;
				my $prep = $4;
				if($prep =~/\w/ && $t =~/\b(length|width|presence|\w+tion)\b/){next;}
				$t =~ tr/A-Z/a-z/;
				$nouns{$t} = 1;
				if($debugnouns){ print "[noun2:$t] $originalsent\n";}
			}
			**/
			
			Set<String> nouns2 = this.getNounsEndOfSentence(oSentence);
			nouns.addAll(nouns2);
			
			// noun rule 3: proper nouns and acronyms

			
			String copy = oSentence;
			String[] segs = copy.split("[()\\[\\]\\{\\}]");
			for (int i1=0;i1<segs.length;i1++) {
				String seg = segs[i1];
				// seg = seg.replaceAll("-", "aaa");
				// seg = seg.replaceAll("[\\p{Punct}]",""); 
				// seg = seg.replaceAll("aaa","-");
				seg = this.removePunctuation(seg, "-");
				String[] tokens = seg.split("\\s+");
				tokens[0]="";
				
				for (int j=0;j<tokens.length;j++) {
					/**
					 * 				if($t =~ /[A-Z].+/ and $t!~/-\w+ed$/){#proper nouns and acronyms, S-shaped
					if($t=~/^[A-Z0-9]+$/){
						$t =~ tr/A-Z/a-z/;
						$anouns{$t} =1;
					}else{
						$t =~ tr/A-Z/a-z/;
						$pnouns{$t} =1;
					}			
					$nouns{$t}=1;
					if($debugnouns) {print "[noun3:$t] $originalsent\n";}
				}
					 */
					
					String token = tokens[j];
					if (token.matches("^.*[A-Z].+$") && (!token.matches("^.*-\\w+ed$"))) {
						if (token.matches("^[A-Z0-9]+$")) {
							token = token.toLowerCase();
							anouns.add(token);
						}
						else {
							token = token.toLowerCase();
							pnouns.add(token);
						}
						nouns.add(token);
					}
				}
			}
			
			// noun rule 4: non-stop/prep followed by a number: epibranchial 4 descriptor heuristics 
			Set<String> nouns4 = this.getNounsRule4(oSentence);
			nouns.addAll(nouns4);
			
			/**
			 * 			
			$originalsent =~ s#-#aaa#g;
			$originalsent =~ s#[[:punct:]]##g; #keep "-"
			$originalsent =~ s#aaa#-#g;
			 */
			
			// remove puncts for descriptor rules
			//oSentence.replaceAll("-", "aaa");
			//oSentence.replaceAll("[\\p{Punct}]", "");
			//oSentence.replaceAll("aaa", "-");
			oSentence = this.removePunctuation(oSentence, "-");
			
			/**
			 * 		
		if($source =~ /\.xml_\S+_/ and $originalsent !~ /\s/){#single word
			if(grep(/^$originalsent$/, keys(%nouns)) < 1){
				$originalsent =~ tr/A-Z/a-z/;
				$descriptors{$originalsent}=1;
				if($debugnouns){ print "[desp:$originalsent] $originalsent\n";}
			}
		}	
			 */
			// Descriptor rule 1: single term descriptions are descriptors
			// ???
			
			// Descriptor rule 2: (is|are) red: isDescriptor 
			/**
			 * 		@tokens = split(/\s+/, $originalsent);
		foreach my $t (@tokens){
			if(isDescriptor($t)){
				$t =~ tr/A-Z/a-z/;
				$descriptors{$t}=1;
				if($debugnouns) {print "[desp:$t] $originalsent\n";}
			}
		}
			 */
			
			descriptors.addAll(this.getNounsDescriptorsRule2(oSentence));
		}
	}
	
	Set<String> filteOutDescriptors(Set<String> rNouns, Set<String> descriptors) {
		Set<String> filtedNouns = new HashSet<String>();

		Iterator<String> iter = rNouns.iterator();
		while (iter.hasNext()) {
			String noun = iter.next();
			noun = noun.toLowerCase();

			Pattern p = Pattern.compile("\\b(" + this.PREPOSITION + "|"
					+ this.STOP + ")\\b", Pattern.CASE_INSENSITIVE);
			Matcher m = p.matcher(noun);

			if ((!m.lookingAt()) && (!descriptors.contains(noun))) {
				filtedNouns.add(noun);
			}
		}
		return filtedNouns;
	}

	/**
	 * 
	 * @param text
	 *            : string in which all punctuations to remove
	 * @param c
	 *            : a punctuatin to keep
	 * @return: string after puctuations are removed except the one in c
	 */

	public String removePunctuation(String text, String c) {
		//System.out.println("Old: " + text);
		if (c == null) {
			text = text.replaceAll("[\\p{Punct}]", "");
		} else {
			text = text.replaceAll(c, "aaa");
			text = text.replaceAll("[\\p{Punct}]", "");
			text = text.replaceAll("aaa", c);
		}
		//System.out.println("New: " + text);

		return text;
	}

	public Set<String> getNounsDescriptorsRule2(String oSent) {
		Set<String> descriptors = new HashSet<String>();
		
		String[] tokens = oSent.split("\\s+");
		
		for (int i=0;i<tokens.length;i++) {
			String token = tokens[i];
			//if (isDescriptor(token)) {
			if (true) {
				token = token.toLowerCase();
				descriptors.add(token);
			}
		}
				
		return descriptors;
	}
	
	
	
	// noun rule 4: non-stop/prep followed by a number: epibranchial 4 descriptor heuristics 
	public Set<String> getNounsRule4(String oSent) {
		Set<String> nouns = new HashSet<String>();
		
		/**
		 * 		
	$cp = $originalsent;
	while($cp =~ /(.*?)\s(\w+)\s+\d+(.*)/){
		my $t = $2;
		$cp = $3;
		if($t !~ /\b($PREPOSITION|$stop)\b/){
			$t =~ tr/A-Z/a-z/;
			$nouns{$t} = 1;
			if($debugnouns){ print "[noun4:$t] $originalsent\n";}
		}
	}	
		 */
		
		String copy = oSent;
		String regex = "(.*?)\\s(\\w+)\\s+\\d+(.*)";
				
		while (true) {
			if (copy==null) {
				break;
			}
			Matcher m = Pattern.compile(regex).matcher(copy);
			if (m.lookingAt()) {
				String t = m.group(2);
				copy = m.group(3);
				String regex2 = "\\b("+this.PREPOSITION+"|"+this.STOP+")\\b"; 
				if (!t.matches(regex2)) {
					t.toLowerCase();
					nouns.add(t);
				}
			}
			else {
				break;
			}
		}		
		
		return nouns;
	}

	public Set<String> getNounsEndOfSentence(String oSent) {
		String copy = oSent;
		String regex = "(.*?)\\b(a|an|the|some|any|this|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) +(\\w+)\\s*($|\\(|\\[|\\{|\\b"
				+ this.PREPOSITION + "\\b)(.*)";
		Set<String> nouns = new HashSet<String>();

		while (true) {
			if (copy == null) {
				break;
			}
			Matcher m = Pattern.compile(regex).matcher(copy);
			if (m.lookingAt()) {
				String t = m.group(3);
				String prep = m.group(4);
				copy = m.group(5);
				// String t6 = m.group(6);
				// copy = m.group(5);
				// String prep = m.group(4);
				if (prep.matches("^.*\\w.*$")
						&& t.matches("^.*\\b(length|width|presence|\\w+tion)\\b.*$")) {
					continue;
				}
				t = t.toLowerCase();
				nouns.add(t);
			} else {
				break;
			}
		}

		return nouns;
	}

	/**
	 * Meckle#s cartilage
	 */
	
	public Set<String> getNounsMecklesCartilage(String oSent) {
		Set<String> nouns = new HashSet<String>();
		String regex = "^.*\\b(\\w+#s)\\b.*$";
		Matcher m = Pattern.compile(regex).matcher(oSent);
		if (m.lookingAt()) {
			String noun = "";
			noun = m.group(1);

			noun = noun.toLowerCase();
			nouns.add(noun);

			noun = noun.replaceAll("#", "");
			nouns.add(noun);

			noun = noun.replaceAll("s$", "");
			nouns.add(noun);
		}

		return nouns;
	}
	
	
	/** 
	 * <i></i> enclosed taxon names  
	 **/
	public Set<String> getTaxonNameNouns (String oSent) {
		Set<String> taxonNames = new HashSet<String>();
		String regex = "(.*?)<\\s*i\\s*>\\s*([^<]*)\\s*<\\s*\\/\\s*i\\s*>(.*)";
		String copy = oSent;
		//<\\s*/?\\s*i\\s*>
		
		while (true) {
			Matcher matcher = Pattern.compile(regex).matcher(copy);
			if (matcher.lookingAt()) {
				String taxonName = matcher.group(2);
				if (taxonName.length() > 0) {
					taxonNames.add(taxonName);
					String[] taxonNameArray = taxonName.split("\\s+");
					for (int i = 0; i < taxonNameArray.length; i++) {
						taxonNames.add(taxonNameArray[i]);
					}
					copy = matcher.group(3);
				} else {
					break;
				}
			} else {
				break;
			}
		}
		
		return taxonNames;
	}

	List<String> getSingularPluralPair(String word1, String word2) {
		List<String> pair = new ArrayList<String>();
		String singular = "";
		String plural = "";
		int len1 = word1.length();
		int len2 = word2.length();
		if (len1 < len2) {
			String temp_word = word1;
			word1 = word2;
			word2 = temp_word;
			int temp_len = len1;
			len1 = len2;
			len2 = temp_len;
		}

		if ((word2.matches("^.*" + this.SENDINGS))
				&& (word1.matches("^.*" + this.PENDINGS))) {

			if (word1.matches("^.*" + "es$") && word2.matches("^.*" + "is$")
					&& Math.abs(len1 - len2) == 0) {
				singular = word2;
				plural = word1;
			} else if (word1.matches("^.*" + "a$")
					&& word2.matches("^.*" + "on$")
					&& Math.abs(len1 - len2) < 2) {
				singular = word2;
				plural = word1;
			} else if (word1.matches("^.*" + "a$")
					&& word2.matches("^.*" + "um$")
					&& Math.abs(len1 - len2) < 2) {
				singular = word2;
				plural = word1;
			} else if (word1.matches("^.*" + "i$")
					&& word2.matches("^.*" + "us$")
					&& Math.abs(len1 - len2) < 2) {
				singular = word2;
				plural = word1;
			} else if (word1.matches("^.*" + "a$")
					&& word2.matches("^.*" + "us$")
					&& Math.abs(len1 - len2) < 2) {
				singular = word2;
				plural = word1;
			}

		} else {
			// thicker, thickness; species, specimens; tomentulose, tomentulous;
			// later laterals
			if (word2.matches("^.*s$")) {
				if (getSingularPluralPairHelper(word1, word2)) {
					singular = word1;
					plural = word2;
				}
			}
		}

		if ((!singular.equals("")) && (!plural.equals(""))) {
			pair.add(singular);
			pair.add(plural);
		}

		return pair;
	}

	// word2 has no other letters except those appearing in word1 or ies, and
	// vice versa.
	public boolean getSingularPluralPairHelper(String word1, String word2) {
		int len1 = word1.length();
		int len2 = word2.length();

		if ((!word2.matches("^\\[^" + word1 + "yies" + "\\]*&"))
				&& (!word1.matches("^\\[^" + word2 + "yies" + "\\]*&"))
				&& (Math.abs(len1 - len2) > 0) 
				&& (Math.abs(len1 - len2) < 3)) {
			return true;
		} else {

			return false;
		}
	}
	
	//if($t !~ /\b(?:$STOP)\b/ && $t =~/\w/ && $t !~ /\d/ && length $t > 1){
	public boolean isWord(String token) {
		String regex = "\\b("+this.STOP+")\\b";
		if (token.matches(regex)) {
			return false;
		}
		
		if (!token.matches("\\w+")) {
			return false;
		}
		
		if (token.length()<=1) {
			return false;
		}	
		
		return true;
	}
	
	public String getRoot (String word) {
		String root;
		this.myStemmer.add(word.toCharArray(), word.length());
		this.myStemmer.stem();
		root = this.myStemmer.toString();
		return root;
	}

	public String getPresentAbsentNouns(String text) {
		
		String pachecked = "and|or|to";
		
//		if($text =~ /(\w+?)\s+(present|absent)/){
//			my $n = $1;
//			if($n !~ /\b($pachecked)\b/ && $n!~/\b($STOP)\b/ && $n !~/\b(always|often|seldom|sometimes|[a-z]+ly)\b/){
//				print "present/absent [$n]\n";
//				
//				if(($n =~/$PENDINGS/ or $n =~/[^s]s$/ or $n =~ /teeth/) and $n !~/$SENDINGS/){
//					push(@NOUNS, $n."[p]");
//				}else{
//					push(@NOUNS, $n."[s]");
//				}
//				$pachecked .= "|$n";
//			}
//		}
		
		if (text.matches("(\\w+?)\\s+(present|absent)")) {
			System.out.println(text);
		}

		// Matcher matcher = Pattern.compile("(^.*?)\\s+([:;\\.].*$)")
		Matcher matcher = Pattern.compile("^.*?(\\w+?)\\s+(present|absent).*$")
				.matcher(text);
		if (matcher.lookingAt()) {

			String word = matcher.group(1);
			//String word1 = matcher.group();
			//String word2= matcher.group(2);
			
			/**
			 * if($n !~ /\b($pachecked)\b/ && $n!~/\b($STOP)\b/ && $n
			 * !~/\b(always|often|seldom|sometimes|[a-z]+ly)\b/){
			 **/
			if ((!word.matches("\\b(" + pachecked + ")\\b"))
					&& (!word.matches("\\b(" + this.STOP + ")\\b"))
					&& (!word.matches("\\b(always|often|seldom|sometimes|[a-z]+ly)\\b"))) {
				
				//print "present/absent [$n]\n";
				System.out.println("present/absent "+word+"\n");
				
				/**
				 * if(($n =~/$PENDINGS/ or $n =~/[^s]s$/ or $n =~ /teeth/) and
				 * $n !~/$SENDINGS/){
				 **/
				if (((word.matches("^.*" + this.PENDINGS))
						|| (word.matches("^.*[^s]s$")) 
						|| (word.matches("teeth")))
					&& (!word.matches(this.SENDINGS))) {
					return word+"[p]";
				}
				else {
					return word+"[s]";
				}
			}			
		}

		//only one pair of uroneurals present			
		return "";
	}
	

	// ---------------addHeuristicsNouns Help Function----
	// #solve the problem: septa and septum are both s
	// septum - Singular
	// septa -Plural
	// septa[s] => septa[p]
	public String addHeuristicsNounsHelper(String oldNoun, Set<String> words) {
		String newNoun = oldNoun;

		if (oldNoun.matches("^.*a\\[s\\]$")) {
			String noun = oldNoun.replaceAll("\\[s\\]", "");
			System.out.println(noun);
			if (words.contains(noun)) {
				newNoun = noun + "[p]";
			}
		}

		return newNoun;
	}

	public void addStopWords() {
		// my @stops = split(/\|/,$stop);
		// String []temp=this.STOP.split("|");
		List<String> stops = new ArrayList<String>();
		stops.addAll(Arrays.asList(this.STOP.split("\\|")));
		// new ArrayList();
		// for (int i=0;i<temp.length;i++) {
		// stops.add(temp[i]);
		// }
		// push(@stops, "NUM", "(", "[", "{", ")", "]", "}");
		stops.addAll(Arrays.asList(new String[] { "NUM", "(", "[", "{", ")",
				"]", "}", "\\\\d+" }));
		// String []a= {stops,"NUM", "(", "[", "{", ")", "]", "}"};

		// push(@stops, "\\\\d+");
		// stops.addAll(Arrays.asList(new String[]{}));

		// print "stop list:\n@stops\n" if $debug;
		// print STDOUT "stop list:\n@stops\n";;

		System.out.println(stops);
		System.out.println(this.FORBIDDEN);

		for (int i = 0; i < stops.size(); i++) {
			String word = stops.get(i);
			// String reg="\\b("+this.FORBIDDEN+")\\b";
			// boolean f = word.matches(reg);
			if (word.matches("\\b(" + this.FORBIDDEN + ")\\b")) {
				continue;
			}
			// update(word, "b", "*", "wordpos", 0);
			this.wordPOSTable.put(new WordPOSKey(word, "b"), new WordPOSValue(
					"*", 0, 0, null, null));
			System.out.println("Update " + word);
		}
	}

	public void addCharacters() {
		List<String> chars = new ArrayList<String>();
		chars.addAll(Arrays.asList(this.CHARACTER.split("\\|")));

		System.out.println(chars);
		System.out.println(this.CHARACTER);

		for (int i = 0; i < chars.size(); i++) {
			String word = chars.get(i);
			// String reg="\\b("+this.FORBIDDEN+")\\b";
			// boolean f = word.matches(reg);
			if (word.matches("\\b(" + this.FORBIDDEN + ")\\b")) {
				continue;
			}
			// update(word, "b", "*", "wordpos", 0);
			this.wordPOSTable.put(new WordPOSKey(word, "b"), new WordPOSValue(
					"", 0, 0, null, null));
			System.out.println("Update " + word);
		}
	}

	public void addNumbers() {
		List<String> nums = new ArrayList<String>();
		nums.addAll(Arrays.asList(this.NUMBER.split("\\|")));

		System.out.println(nums);
		System.out.println(this.NUMBER);

		for (int i = 0; i < nums.size(); i++) {
			String word = nums.get(i);
			// String reg="\\b("+this.FORBIDDEN+")\\b";
			// boolean f = word.matches(reg);
			if (word.matches("\\b(" + this.FORBIDDEN + ")\\b")) {
				continue;
			}
			// update(word, "b", "*", "wordpos", 0);
			this.wordPOSTable.put(new WordPOSKey(word, "b"), new WordPOSValue(
					"*", 0, 0, null, null));
			System.out.println("Update " + word);
		}
		this.wordPOSTable.put(new WordPOSKey("NUM", "b"), new WordPOSValue("*",
				0, 0, null, null));
	}

	public void addClusterstrings() {
		List<String> cltstrs = new ArrayList<String>();
		cltstrs.addAll(Arrays.asList(this.CLUSTERSTRING.split("\\|")));

		System.out.println(cltstrs);
		System.out.println(this.CLUSTERSTRING);

		for (int i = 0; i < cltstrs.size(); i++) {
			String word = cltstrs.get(i);
			// String reg="\\b("+this.FORBIDDEN+")\\b";
			// boolean f = word.matches(reg);
			if (word.matches("\\b(" + this.FORBIDDEN + ")\\b")) {
				continue;
			}
			// update(word, "b", "*", "wordpos", 0);
			this.wordPOSTable.put(new WordPOSKey(word, "b"), new WordPOSValue(
					"*", 1, 1, null, null));
			System.out.println("Update " + word);
		}
	}

	public void addProperNouns() {
		List<String> ppnouns = new ArrayList<String>();
		ppnouns.addAll(Arrays.asList(this.PROPERNOUN.split("\\|")));

		System.out.println(ppnouns);
		System.out.println(this.PROPERNOUN);

		for (int i = 0; i < ppnouns.size(); i++) {
			String word = ppnouns.get(i);
			// String reg="\\b("+this.FORBIDDEN+")\\b";
			// boolean f = word.matches(reg);
			if (word.matches("\\b(" + this.FORBIDDEN + ")\\b")) {
				continue;
			}
			// update(word, "b", "*", "wordpos", 0);
			this.wordPOSTable.put(new WordPOSKey(word, "z"), new WordPOSValue(
					"*", 0, 0, null, null));
			System.out.println("Update " + word);
		}
	}

	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// suffix: -fid(adj), -form (adj), -ish(adj), -less(adj), -like (adj)),
	// -merous(adj), -most(adj), -shaped(adj), -ous(adj)
	// -ly (adv), -er (advj), -est (advj),
	// foreach unknownword in unknownwords table
	// seperate root and suffix
	// if root is a word in WN or unknownwords table
	// make the unknowword a "b" boundary

	// suffix is defined in global variable SUFFIX
	public void posBySuffix() {
		String p1 = "^[a-z_]+(" + this.SUFFIX + ")$";
		String p2 = "^[._.][a-z]+"; // , _nerved
		Iterator<Map.Entry<String, String>> iterator = this.unknownWordTable
				.entrySet().iterator();

		while (iterator.hasNext()) {
			Map.Entry<String, String> unknownWordEntry = iterator.next();
			String unknownWord = unknownWordEntry.getKey();
			String unknownWordTag = unknownWordEntry.getValue();
			// String unknownWord = "anteriorly";
			// String unknownWordTag = "unknown";
			// the tag of this word is unknown
			if (unknownWordTag.equals("unknown")) {
				if (unknownWord.matches(p1)) {
					Matcher matcher = Pattern.compile(
							"(.*?)(" + this.SUFFIX + ")$").matcher(unknownWord);
					if ((unknownWord.matches("^[a-zA-Z0-9_-]+$"))
							&& matcher.matches()) {
						if (this.containSuffix(unknownWord, matcher.group(1),
								matcher.group(2))) {
							this.wordPOSTable.put(new WordPOSKey(unknownWord,
									"b"), new WordPOSValue("*", 0, 0, null,
									null));
							System.out
									.println("posBySuffix set $unknownword a boundary word\n");
						}
					}
				}

				if (unknownWord.matches(p2)) {
					// unknownWordTable.put(unknownWord, "b");
					this.wordPOSTable.put(new WordPOSKey(unknownWord, "b"),
							new WordPOSValue("*", 0, 0, null, null));
					System.out
							.println("posbysuffix set $unknownword a boundary word\n");
				}
			}
		}
	}

	// return false or true depending on if the word contains the suffix as the
	// suffix
	public boolean containSuffix(String word, String base, String suffix) {
		boolean flag = false; // return value
		boolean wordInWN = false; // if this word is in WordNet
		boolean baseInWN = false;
		WordNetAPI myWN;

		// check base
		// this if statement is added by Dongye
		if (base.length() == 0) {
			return true;
		}

		base.replaceAll("_", ""); // cup_shaped

		if (this.myWN.contains(word)) {
			wordInWN = true; // word is in WordNet
		} else {
			// $wnoutputword =~ s#\n# #g;

			wordInWN = false;
		}

		if (this.myWN.contains(base)) {
			baseInWN = true;
		} else {
			// $wnoutputbase =~ s#\n# #g;
			baseInWN = false;
		}

		// if WN pos is adv, return 1: e.g. ly, or if $base is in
		// unknownwords
		// table
		if (suffix.equals("ly")) {
			if (wordInWN) {
				// if($wnoutputword =~/Overview of adv $word/){
				if (this.myWN.isAdverb(word)) {
					return true;
				}
			}
			// if the word is in unknown word set, return true
			if (this.unknownWordTable.containsKey(base)) {
				return true;
			}
		}

		// if WN recognize superlative, comparative adjs, return 1: e.g. er,
		// est
		else if (suffix.equals("er") || suffix.equals("est")) {
			if (wordInWN) {
				// if($wnoutputword =~/Overview of adj (\w+)/){#$word =
				// softer,
				// $1 = soft vs. $word=$1=neuter
				// $word = softer, $1 = soft vs. $word=$1=neuter
				if (this.myWN.isAdjective(word) || this.myWN.isAdverb(word)) {
					return true;
				}
				// return 1 if $word=~/^$1\w+/;
			}
		}

		// if $base is in WN or unknownwords table, or if $word has sole pos
		// adj
		// in WN, return 1: e.g. scalelike
		else {
			if (this.myWN.isSoleAdjective(word)) {
				return true;
			}
			if (baseInWN) {
				return true;
			}
			if (this.unknownWordTable.containsKey(base)) {
				return true;
			}
		}

		return flag;
	}

	public void markupByPattern() {
		System.out.println("markupbypattern start");
		// int cap=this.sentence.size();
		int cap = this.sentenceTable.size();
		// ((ArrayList)this.tag).ensureCapacity(cap);
		// ((ArrayList)this.modifier).ensureCapacity(cap);
		// for (int i=0;i<this.originalSent.size();i++) {
		for (int i = 0; i < cap; i++) {
			// case 1
			// if (this.originalSent.get(i).matches("^x=.*")) {
			if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^x=.*")) {
				// tag.set(i, "chromosome");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("chromosome");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 2
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^2n=.*")) {
				// tag.set(i, "chromosome");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("chromosome");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 3
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^x .*")) {
				// tag.set(i, "chromosome");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("chromosome");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 4
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^2n .*")) {
				// tag.set(i, "chromosome");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("chromosome");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 5
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^2 n.*")) {
				// tag.set(i, "chromosome");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("chromosome");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 6
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^fl.*")) {
				// tag.set(i, "flowerTime");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("flowerTime");
				this.sentenceTable.get(i).setModifier("");
			}
			// case 7
			else if (this.sentenceTable.get(i).getOriginalSentence()
					.matches("^fr.*")) {
				// tag.set(i, "flowerTime");
				// modifier.set(i, "");
				this.sentenceTable.get(i).setTag("flowerTime");
				this.sentenceTable.get(i).setModifier("");
			}
		}
		System.out.println("markupbypattern end");
	}

	// private String IGNOREPTN ="(IGNOREPTN)"; //disabled
	public void markupIgnore() {
		// $sth =
		// $dbh->prepare("update ".$prefix."_sentence set tag = 'ignore', modifier='' where originalsent rlike '(^| )$IGNOREPTN ' ");
		for (int i = 0; i < this.sentenceTable.size(); i++) {
			String thisSent = this.sentenceTable.get(i).getOriginalSentence();
			String p = "(^| )" + this.IGNOREPTN;
			if (thisSent.matches("(^|^ )" + this.IGNOREPTN + ".?")) {
				sentenceTable.get(i).setTag("ignore");
				sentenceTable.get(i).setModifier("");
			}
		}
	}
	
	public int discover (String s) {
		int newDisc = 0;
		
		for (int i=0;i<this.sentenceTable.size();i++) {
			Sentence sentEntry = sentenceTable.get(i);
			//sentid
			String sent = sentEntry.getSentence();
			String lead = sentEntry.getLead();
			String tag = sentEntry.getTag();
			String status = sentEntry.getStatus();
			if (!(tag == null || !tag.equals("ignore") && status.equals(s))) {
				continue;
			}
			
			String[] startWords = lead.split("\\s+");
			//@startwords = split(/\s+/,$lead);
			
			//$pattern = buildpattern(@startwords);
			String pattern = buildPattern(startWords);
			
			if (pattern.matches("^.*\\w+.*$")) {
				// ids of untagged sentences that match the pattern
				Set<Integer> matched = matchPattern(pattern, status, false); 
				int round = 0;
				int numNew = 0;
				
				do {
					numNew = ruleBasedLearn(matched);
					newDisc= newDisc+numNew;
					round++;
				} while(numNew>0);
			}

		}
		
		return newDisc;
	}

	/**
	 * return a positive number if anything new is learnt from @source sentences
	 * by applying rules and clues to grow %NOUNS and %BDRY and to confirm tags
	 * create and maintain decision tables
	 * 
	 * @param matched
	 * @return
	 */
	public int ruleBasedLearn(Set<Integer> matched) {
		
		int sign = 0;
		int numNew = 0;
		String tag = "";

		Iterator<Integer> iter = matched.iterator();
		while (iter.hasNext()) {
			int sentID = iter.next().intValue();
			Sentence sent = this.sentenceTable.get(sentID);
			if (sent.getTag() != null) {
				// ($tag, $new) = doit($sentid);
				doIt(sentID);
				// tag($sentid, $tag);
				tagIt(sentID,tag);
				sign = sign+numNew;
			}
		}		
		
		return 0;
	}

	// update wordpos table (on certainty) when a sentence is tagged for the
	// first time. this update should not be done when a pos is looked up,
	// because we may lookup a pos for the same example multiple times. if the
	// tag need to be adjusted (not by doit function), also need to adjust
	// certainty counts.
	public void doIt(int sentID) {
		int sign =0;
		
		Sentence sentEntry = this.sentenceTable.get(sentID);
		String sent = sentEntry.getSentence();
		String lead = sentEntry.getLead();
		
		String[] words = lead.split("\\s+");
		String ptn = this.getPOSptn(words);
		
		Pattern p;
		Matcher m;
		
		// Case 1: single word case
		if (ptn.matches("^[pns]$")) {
			String tag = words[0];
			sign = sign+updateTable(tag,ptn,"-","wordpos",1);
		}
		
		// Case 2: the POSs are "ps"
		else {
		p = Pattern.compile("^.*ps.*$");
		m = p.matcher(ptn);
		if (m.find()) {
			int start = m.start();
			int end = m.end();
			String pWord = words[start];
			String sWord = words[end-1];
			
			sign += updateTable(pWord, "p", "-", "wordpos",1);
			sign += updateTable(sWord, "s", "", "wordpos", 1);
			

			//$sign += updatenn(0, $#tws+1, @tws); #up to the "p" inclusive

			
			
		}
		else {
		p = Pattern.compile("^.*p(\\?).*$");
		m = p.matcher(ptn);
		if (m.find()) {
			int start = m.start();
		}
			}
		}		
	}
	
	/**
	 * The length of the ptn must be the same as the number of words in words. If certainty is < 50%, replace POS with ?.
	 * @param words
	 * @return
	 */
	public String getPOSptn(String[] words) {
		String ptn = "";
		for (int i = 0; i < words.length; i++) {
			String word = words[i];
			List<POSInfo> POSInfoList = checkPOSInfo(word);
			if (POSInfoList.size() > 0) {
				POSInfo p = POSInfoList.get(0);
				String POS = p.getPOS();
				String role = p.getRole();
				double certainty = (double) p.getCertaintyU()
						/ (double) p.getCertaintyL();

				if ((!POS.equals("?")) && (certainty <= 0.5)) {
					// This POS has a certainty less than 0.5. It is ignored.
					POS = "?";
				}
				ptn = ptn + POS;
			}
		}

		return ptn;
	}

	/**
	 * It usually return all
	 * @param word
	 * @return a list of POSInfo objects in descending order of certaintyU/certaintyL
	 */
	public List<POSInfo> checkPOSInfo(String word) {
		List<POSInfo> POSInfoList = new ArrayList<POSInfo>();

		word = this.removeAll(word, "^\\s*");
		word = this.removeAll(word, "\\s+$");

		if (word.matches("^\\d+.*$")) {
			POSInfo p = new POSInfo("b", "", 1, 1);
			POSInfoList.add(p);
			return POSInfoList;
		}

		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter = this.wordPOSTable
				.entrySet().iterator();
		while (iter.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> e = iter.next();
			String w = e.getKey().getWord();
			if (w.equals(word)) {
				String POS = e.getKey().getPOS();
				String role = e.getValue().getRole();
				int certaintyU = e.getValue().getCertaintyU();
				int certaintyL = e.getValue().getCertaintyL();
				POSInfo p = new POSInfo(POS, role, certaintyU, certaintyL);
				POSInfoList.add(p);
			}
		}

		// nothing found
		if (POSInfoList.size() == 0) {
			return new ArrayList<POSInfo>();
		} else {
			// sort the list in  ascending order of certaintyU/certaintyL
			Collections.sort(POSInfoList);
			// reverse it into descending order
			Collections.reverse(POSInfoList);
			
			return POSInfoList;
		}
	}

	public void tagIt(int sentID, String tag) {
		;
	}

	public Set<Integer> matchPattern(String pattern, String s, boolean hasTag) {
		
		Set<Integer> matchedIDs = new HashSet<Integer>();
		
		for (int i =0;i<this.sentenceTable.size();i++) {
			Sentence sent = this.sentenceTable.get(i);
			String sentence = sent.getSentence();
			String status = sent.getStatus();
			String tag = sent.getTag();
			if ((hasTag && (tag != null) && (status.equals(s)) ) 
					|| ((!hasTag) && (tag == null) && (status.equals(s))) ) {
				Pattern p = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
				Matcher m = p.matcher(sentence);
				if (m.lookingAt()) {
					matchedIDs.add(i);
				}
			}
		}	
		
		return matchedIDs;
	}
	
	/**
	 * 
	 * @param startWords
	 * @return
	 */
	public String buildPattern(String[] startWords) {
		Set<String> newWords = new HashSet<String>();
		String temp = "";
		String prefix = "\\w+\\s";
		String pattern = "";
		
		for (int i = 0; i < startWords.length; i++) {
			String word = startWords[i];
			Pattern p = Pattern.compile(":" + word + ":",
					Pattern.CASE_INSENSITIVE);
			Matcher m = p.matcher(this.CHECKEDWORDS);
			// TODO: This is not very sure, need to make sure - Dongye
			if ((!word.matches("[\\p{Punct}0-9]")) && (!m.lookingAt())) {
				temp = temp + word + "|";
				newWords.add(word);
			}
		}

		// no new words
		if (!temp.matches("^.*\\w.*$")) {
			return "";
		}
		
		// remove the last char, which is a '|'
		temp = temp.substring(0, temp.length()-1);
		temp = "\\b(?:"+temp+")\\b";
		
		pattern = "^"+temp+"|"; 
		
		for (int j=0;j<this.NUM_LEAD_WORDS-1;j++) {
			temp = prefix+temp;
			pattern = pattern + "^"+temp+"|";
		}
		
		pattern = pattern.substring(0, pattern.length()-1);
		
		pattern = "(?:"+pattern+")";
		
		this.CHECKEDWORDS = this.updateCheckedWords(":", this.CHECKEDWORDS, newWords);
		
		return pattern;
	}

	public void learn(List<Treatment> treatments) {
		


		//List<String> fileNameList = fileLoader.getFileNameList();
		//List<Integer> typeList = fileLoader.getTypeList();
		
		//List<String> textList = fileLoader.getTextList();
		
		
		// process treatments
		this.populateSents(treatments);
		
		// pre load words
		this.addHeuristicsNouns();
		this.addStopWords();
		this.addCharacters();
		this.addNumbers();
		this.addClusterstrings();
		this.addProperNouns();
		
		// ???
		this.posBySuffix();
		this.markupByPattern();
		this.markupIgnore();
		
		// learning rules with high certainty
		this.discover("start");
		// bootstrapping rules
		this.discover("normal");
				
		System.out.println("Method: learn - Done!\n");
	}

	public Map<Treatment, List<String>> getSentences() {
		System.out.println("Method: getSentences\n");
		return null;
	}

	public Map<Treatment, List<String>> getSentencesForOrganStateMarker() {
		System.out.println("Method: getSentencesForOrganStateMarker\n");
		return null;
	}

	public List<String> getAdjNouns() {
		System.out.println("Method: getAdjNouns\n");
		return null;
	}

	public Map<String, String> getAdjNounSent() {
		System.out.println("Method: getAdjNounsSent\n");
		return null;
	}

	public Set<String> getBracketTags() {
		System.out.println("Method: getAdjNounsSent\n");
		return null;
	}

	public Set<String> getWordRoleTags() {
		System.out.println("Method: getSentenceTags\n");
		return null;
	}

	public Map<String, Set<String>> getWordToSources() {
		System.out.println("Method: getBracketTags\n");
		return null;
	}

	public Map<String, Set<String>> getRoleToWords() {
		System.out.println("Method: getRoleToWords\n");
		return null;

	}

	public Map<String, Set<String>> getWordsToRoles() {
		System.out.println("Method: getWordsToRoles\n");
		return null;
	}

	public Map<String, String> getHeuristicNouns() {
		System.out.println("Method: getHeuristicNouns\n");
		return null;
	}

	public Map<Treatment, List<String>> getSentenceTags() {
		System.out.println("Method: getTermCategories\n");
		return null;
	}

	public Map<String, Set<String>> getTermCategories() {
		System.out.println("Method: getTermCategories\n");
		return null;
	}

	public boolean testWN(String word) {
		try {
			WordNetAPI myWN = new WordNetAPI(
					"/Users/nescent/Phenoscape/WordNet-3.0/dict", false);

			if (myWN.isNoun(word)) {
				System.out.println(word + " is a noun");
			}
			if (myWN.isVerb(word)) {
				System.out.println(word + " is a verb");
			}
			if (myWN.isAdjective(word)) {
				System.out.println(word + " is a adj");
			}
			if (myWN.isAdverb(word)) {
				System.out.println(word + " is a adv");
			}

			return true;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false;
		}
	}
	
	// ---------------CLASS Helper function----------------
	public String trimString (String text){
		String myText = text;
		myText = myText.replaceAll("^\\s+|\\s+$", "");
		return myText;
	}
	
	/**
	 * 
	 * @param expr
	 * @param checkedWords
	 * @param list
	 * @return
	 */
	public String updateCheckedWords(String expr, String checkedWords,
			Set<String> list) {
		String newCheckedWords = checkedWords;
		Iterator<String> iter = list.iterator();

		while (iter.hasNext()) {
			newCheckedWords = newCheckedWords + iter.next()+":";
		}
		//newCheckedWords = newCheckedWords + ":";

		return newCheckedWords;
	}

	public int updateTable(String word, String pos, String role, String table,
			int increment) {
		int result = 0;

		word = this.processWord(word);
		// empty word
		if (word.length() < 1) {
			return 0;
		}

		// forbidden word
		if (word.matches("\\b(?:" + this.FORBIDDEN + ")\\b")) {
			return 0;
		}

		if (pos.equals("n")) {
			//	$pos = getnumber($word);
			pos = getNumber(word);
		}

		result = result + markKnown(word, pos, role, table, increment);

		// to eliminate reduandent computation
		if (!inSingularPluralPair(word)) {
			if (pos.equals("p")) {
				String pl = word;
				word = getSingular(word);
				// add "*" and 0: pos for those words are inferred based on
				// other clues, not seen directly from the text
				result = result + this.markKnown(word, "s", "*", table, 0);
				addSingularPluralPair(word, pl);
			}
			if (pos.equals("s")) {
				//List<String> words = getPlural(word);
				String[] words = this.getPlural(word);
				String sg = word;
				for (int i = 0; i < words.length; i++) {
					if (words[i].matches("^.*\\w.*$")) {
						result = result
								+ this.markKnown(words[i], "p", "*", table,
										0);
					}
					addSingularPluralPair(sg, words[i]);
				}
			}
		}

		return result;
	}

	public String[] getPlural(String word) {
		
		if (word.matches("^(n|2n|x)$")) {
			return null;
		}
		
		String plural = this.PLURALS.get(word);
		if (plural.matches("^.*\\w+.*$")) {
			return plural.split(" ");
		}
		
		plural = getPluralSpecialCaseHelper(word);
		if (plural == null) {
			plural = getPluralRuleHelper(word);
			if (plural != null) {
				plural = plural+""+word+"s";
			}	
		}

		// Avoid null
		if (plural == null) {
			plural = "";
		}
		
		plural=plural.replaceAll("^\\s+", "");
		plural=plural.replaceAll("\\s+$", "");
		String[] pls = plural.split(" ");
		String plStr = "";
		for (int i=0;i<pls.length;i++) {
			if (this.WORDS.get(pls[i])>=1) {
				plStr = plStr+pls[i]+" ";
			}
		}
		plStr = plStr.replaceAll("\\s+$", "");
		this.PLURALS.put(word, plStr);
		
		return plStr.split(" ");
	}

	/**
	 * A helper method used by method getPlural. Help to apply a number of rules
	 * 
	 * @param word
	 * @return if the word has plural form(s), return it(them); otherwise return ""
	 */
	public String getPluralRuleHelper(String word) {
		String plural;
		Pattern p;
		Matcher m;

		p = Pattern.compile("(^.*?)(ex|ix)$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "ices";
			plural = plural + " " + m.group(1) + m.group(2) + "es";
			return plural;
		}

		p = Pattern.compile("^.*(x|ch|ss|sh)$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = word + "es";
			return plural;
		}

		p = Pattern.compile("(^.*?)([^aeiouy])y$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + m.group(2) + "ies";
			return plural;
		}

		p = Pattern.compile("(^.*?)(?:([^f])fe|([oaelr])f)$");
		m = p.matcher(word);

		if (m.lookingAt()) {
			String s1 = m.group(1);
			String s2 = m.group(2);
			String s3 = m.group(3);
			if (s2 != null) {
				plural = s1 + s2 + "ves";
			} else {
				plural = s1 + s3 + "ves";
			}
			return plural;
		}

		p = Pattern.compile("(^.*?)(x|s)is$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + m.group(2) + "es";
			return plural;
		}

		p = Pattern.compile("(^.*?)([tidlv])um$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + m.group(2) + "a";
			return plural;
		}

		p = Pattern.compile("(^.*?)(ex|ix)$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "ices";
			return plural;
		}

		p = Pattern.compile("(^.*?[^t][^i])on$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "a";
			return plural;
		}

		p = Pattern.compile("(^.*?)a$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "ae";
			return plural;
		}

		p = Pattern.compile("(^.*?)man$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "men";
			return plural;
		}

		p = Pattern.compile("(^.*?)child$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "children";
			return plural;
		}

		p = Pattern.compile("(^.*)status$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "statuses";
			return plural;
		}

		p = Pattern.compile("(^.+?)us$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "i";
			plural = plural + " " + m.group(1) + "uses";
			return plural;
		}

		p = Pattern.compile("^.*s$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = word + "es";
			return plural;
		}

		return "";
	}

	/**
	 * A helper method used by method getPlural. Help to handle special cases.
	 * 
	 * @param word
	 * @return if the word has a plural, return it; otherwise return ""
	 */
	public String getPluralSpecialCaseHelper(String word) {
		String plural;
		Pattern p;
		Matcher m;

		p = Pattern.compile("^.*series$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = word;
			return plural;
		}

		p = Pattern.compile("(^.*?)foot$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "feet";
			return plural;
		}

		p = Pattern.compile("(^.*?)tooth$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "teeth";
			return plural;
		}

		p = Pattern.compile("(^.*?)alga$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "algae";
			return plural;
		}

		p = Pattern.compile("(^.*?)genus$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "genera";
			return plural;
		}

		p = Pattern.compile("(^.*?)corpus$");
		m = p.matcher(word);
		if (m.lookingAt()) {
			plural = m.group(1) + "corpora";
			return plural;
		}

		return "";
	}

	/**
	 * 
	 * @param sgl
	 * @param pl
	 * @return if add a pair, return true; otherwise return false
	 */
	public boolean addSingularPluralPair(String sgl, String pl) {
		boolean is_exist = false;
		Iterator<SingularPluralPair> iter = this.singularPluralTable.iterator();

		while (iter.hasNext()) {
			SingularPluralPair spp = iter.next();
			if ((spp.getSingular().equals(sgl)) && (spp.getPlural().equals(pl))) {
				is_exist = true;
				break;
			}
		}

		if (!is_exist) {
			SingularPluralPair pair = new SingularPluralPair(sgl, pl);
			this.singularPluralTable.add(pair);
			return true;
		}

		return false;
	}

	/**
	 * 
	 * @param word
	 * @return the singular form of the input word
	 */
	public String getSingular(String word) {
		if (!word.matches("^.*\\w.*$")) {
			return "";
		}

		if (word.equals("valves")) {
			return "valve";
		} else if (word.equals("media")) {
			return "media";
		} else if (word.equals("species")) {
			return "species";
		} else if (word.equals("axes")) {
			return "axis";
		} else if (word.equals("calyces")) {
			return "calyx";
		} else if (word.equals("frons")) {
			return "frons";
		} else if (word.equals("grooves")) {
			return "groove";
		} else if (word.equals("nerves")) {
			return "nerve";
		}

		String singular = "";
		if (getNumber(word).equals("p")) {
			Pattern p = Pattern.compile("(^.*?[^aeiou])ies$");
			Matcher m = p.matcher(word);

			if (m.lookingAt()) {
				singular = m.group(1) + "y";
			} else {
				p = Pattern.compile("(^.*?)i$");
				m = p.matcher(word);
				if (m.lookingAt()) {
					singular = m.group(1) + "us";
				} else {
					p = Pattern.compile("(^.*?)ia$");
					m = p.matcher(word);
					if (m.lookingAt()) {
						singular = m.group(1) + "ium";
					} else {
						p = Pattern.compile("(^.*?(x|ch|sh|ss))es$");
						m = p.matcher(word);
						if (m.lookingAt()) {
							singular = m.group(1);
						} else {
							p = Pattern.compile("(^.*?)ves$");
							m = p.matcher(word);
							if (m.lookingAt()) {
								singular = m.group(1) + "f";
							} else {
								p = Pattern.compile("(^.*?)ices");
								m = p.matcher(word);
								if (m.lookingAt()) {
									singular = m.group(1) + "ex";
								} else {
									// pinnae ->pinna
									p = Pattern.compile("(^.*?a)e$");
									m = p.matcher(word);
									if (m.lookingAt()) {
										singular = m.group(1);
									} else {
										// fruits->fruit
										p = Pattern.compile("(^.*?)s$");
										m = p.matcher(word);
										if (m.lookingAt()) {
											singular = m.group(1);
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (singular.matches("^.*\\w.*$")) {
			return singular;
		}

		singular = checkWN(word, "singular");
		if (singular.matches("^.*\\w.*$")) {
			return singular;
		}

		return null;
	}

	/**
	 * 
	 * @param word
	 * @return if the word is in the SingularPluralTable
	 */

	public boolean inSingularPluralPair(String word) {
		// TODO Auto-generated method stub
		Iterator<SingularPluralPair> iter = this.singularPluralTable.iterator();

		while (iter.hasNext()) {
			SingularPluralPair spp = iter.next();
			if ((spp.getSingular().equals(word))
					|| (spp.getPlural().equals(word))) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 
	 * @param word
	 * @param pos
	 * @param role
	 * @param table
	 * @param increment
	 * @return
	 */
	public int markKnown(String word, String pos, String role, String table,
			int increment) {

		String sth = "";
		String pattern = "";
		int sign = 0;
		String otherPrefix = "";
		String spWords = "";

		// empty word
		// if (word.length() < 1) {
		// return 0;
		// }

		// forbidden word
		if (word.matches("\\b(?:" + this.FORBIDDEN + ")\\b")) {
			return 0;
		}

		// stop words
		if (word.matches("^(" + this.STOP + ")$")) {
			sign = sign
					+ processNewWord(word, pos, role, table, word, increment);
			return sign;
		}

		sign = sign + processNewWord(word, pos, role, table, word, increment);

		Pattern p = Pattern.compile("^(" + this.PREFIX + ")(\\S+).*$");
		Matcher m = p.matcher(word);
		if (m.lookingAt()) {
			String g1 = m.group(1);
			String g2 = m.group(2);
			String temp = g2;
			otherPrefix = this.PREFIX;
			otherPrefix = otherPrefix.replace("\\b" + g1 + "\\b", "");
			otherPrefix = otherPrefix.replace("\\|\\|", "|");
			otherPrefix = otherPrefix.replace("^\\|", "");
			spWords = "(" + escape(singularPluralVariations(temp)) + ")";
			pattern = "^(" + otherPrefix + ")?" + spWords + "\\$";

			Iterator<Map.Entry<String, String>> iter1 = this.unknownWordTable
					.entrySet().iterator();
			while (iter1.hasNext()) {
				Map.Entry<String, String> entry = iter1.next();
				String newWord = entry.getKey();
				String flag = entry.getValue();
				if ((newWord.matches(pattern)) && (flag.equals("unknown"))) {
					sign = sign
							+ processNewWord(newWord, pos, "*", table, word, 0);
				}
			}

			// word starts with a lowercase letter
			if (word.matches("^[a-z].*$")) {
				spWords = "(" + escape(singularPluralVariations(word)) + ")";
				// word=shrubs, pattern = (pre|sub)shrubs
				pattern = "^(" + this.PREFIX + ")" + spWords + "\\$";

				Iterator<Map.Entry<String, String>> iter2 = this.unknownWordTable
						.entrySet().iterator();
				while (iter2.hasNext()) {
					Map.Entry<String, String> entry = iter2.next();
					String newWord = entry.getKey();
					String flag = entry.getValue();
					if ((newWord.matches(pattern)) && (flag.equals("unknown"))) {
						sign = sign
								+ processNewWord(newWord, pos, "*", table,
										word, 0);
					}
				}

				// word_$spwords
				spWords = "(" + escape(singularPluralVariations(word)) + ")";
				pattern = ".*_" + spWords + "\\$";
				Iterator<Map.Entry<String, String>> iter3 = this.unknownWordTable
						.entrySet().iterator();
				while (iter3.hasNext()) {
					Map.Entry<String, String> entry = iter3.next();
					String newWord = entry.getKey();
					String flag = entry.getValue();
					if ((newWord.matches(pattern)) && (flag.equals("unknown"))) {
						sign = sign
								+ processNewWord(newWord, pos, "*", table,
										word, 0);
					}
				}
			}
		}

		return sign;
	}

	// in perl, it escape [] {} and () for mysql regexp, not perl regrexp. May not be necessary in Java
	private String escape(String singularPluralVariations) {
		// TODO Auto-generated method stub
		return singularPluralVariations;
	}

	/**
	 * 
	 * @param word
	 * @return all variations of the word
	 */
	//return singular and plural variations of the word
	public String singularPluralVariations(String word) {	
		String variations = word+"|";
		Iterator<SingularPluralPair> iter = this.singularPluralTable.iterator();
		while (iter.hasNext()) {
			SingularPluralPair pair = iter.next();
			String sg = pair.getSingular();
			String pl = pair.getPlural();
			if (sg.equals(word)) {
				variations = variations + pl+"|";
			}
			if (pl.equals(word)) {
				variations = variations + sg+"|";	
			}
		}

		variations = this.removeAll(variations, "\\|+$");
		
		return variations;
	}

	/**
	 * This method handles a new word when for updateTable method
	 * 
	 * @param newWord
	 * @param pos
	 * @param role
	 * @param table
	 * @param flag
	 * @param increment
	 * @return
	 */
	public int processNewWord(String newWord, String pos, String role,
			String table, String flag, int increment) {
		int sign = 0;
		// remove $newword from unknownwords
		updateUnknownWords(newWord, flag);
		// insert $newword to the specified table
		if (table.equals("wordpos")) {
			sign = sign + updatePOS(newWord, pos, role, increment);
		} else if (table.equals("modifiers")) {
			sign = sign + addModifier(newWord, increment);
		}

		return sign;
	}

	/**
	 * This method updates a new word in the unknownWord table
	 * 
	 * @param newWord
	 * @param sourceWord
	 * @return if any updates occured, return true; otherwise, return false
	 */
	public boolean updateUnknownWords(String newWord, String flag) {
		boolean result = false;
		Iterator<Map.Entry<String, String>> iter = this.unknownWordTable
				.entrySet().iterator();
		
		while (iter.hasNext()) {
			Map.Entry<String, String> unknownWord = iter.next();
			if (unknownWord.getKey().equals(newWord)) {
				unknownWord.setValue(flag);
				result = true;
			}
		}
		
		return result;
	}
	
	public int updatePOS(String newWord, String pos, String role, int increment) {
		int n = 0;

		if ((newWord.matches("^.*(\b|_)(NUM|" + this.NUMBER + "|"
				+ this.CLUSTERSTRING + "|" + this.CHARACTER + ")\b.*$"))
				&& (pos.matches("[nsp]"))) {
			return 0;
		}

		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter = this.wordPOSTable
				.entrySet().iterator();
		// boolean isExist = false;
		Map.Entry<WordPOSKey, WordPOSValue> targetWordPOS = null;
		while (iter.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> wordPOS = iter.next();
			if (wordPOS.getKey().getWord().equals(newWord)) {
				targetWordPOS = wordPOS;
				break;
			}
		}
		if (targetWordPOS == null) {
			int certaintyU = 0;
			certaintyU += increment;
			this.wordPOSTable.put(new WordPOSKey(newWord, pos),
					new WordPOSValue(role, certaintyU, 0, null, null));
			n = 1;
		} else {
			String oldPOS = targetWordPOS.getKey().getPOS();
			String oldRole = targetWordPOS.getValue().getRole();
			int certaintyU = targetWordPOS.getValue().getCertaintyU();
			if ((!oldPOS.equals(pos))
					&& ((oldPOS.equals("b")) || (pos.equals("b")))) {
				String otherPOS = pos.equals("b") ? oldPOS : pos;
				pos = resolveConflicts(newWord, "b", otherPOS);
				if (!pos.equals(oldPOS)) { // new pos win
					role = role.equals("*") ? "" : role;
					n = n + changePOS(newWord, oldPOS, pos, role, increment);
				} else { // olde pos win
					role = oldRole.equals("*") ? role : oldRole;
					certaintyU = certaintyU + increment;
					WordPOSKey key = new WordPOSKey("newWord", "pos");
					WordPOSValue value = new WordPOSValue(role, certaintyU, 0,
							null, null);
					this.wordPOSTable.put(key, value);
				}
			} else {
				role = mergeRole(oldRole, role);
				certaintyU += increment;
				WordPOSKey key = new WordPOSKey("newWord", "pos");
				WordPOSValue value = new WordPOSValue(role, certaintyU, 0,
						null, null);
				this.wordPOSTable.put(key, value);
			}
		}

		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter2 = this.wordPOSTable
				.entrySet().iterator();
		int certaintyL = 0;
		while (iter2.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> e = iter2.next();
			if (e.getKey().getWord().equals(newWord)) {
				certaintyL += e.getValue().getCertaintyU();
			}
		}
		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter3 = this.wordPOSTable
				.entrySet().iterator();
		while (iter3.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> e = iter3.next();
			if (e.getKey().getWord().equals(newWord)) {
				e.getValue().setCertiantyU(certaintyL);
			}
		}

		return n;

	}


	/**
	 * 
	 * @param newWord
	 * @param bPOS
	 * @param otherPOS
	 * @return
	 */
	private String resolveConflicts(String newWord, String bPOS,
			String otherPOS) {
		int count = 0;

		for (int i = 0; i < this.sentenceTable.size(); i++) {
			Sentence sent = this.sentenceTable.get(i);
			if ((!sent.getTag().equals("ignore")) || (sent.getTag() != null)) {
				Pattern p = Pattern.compile("([a-z]+(" + this.PLENDINGS
						+ ")) (" + newWord + ")", Pattern.CASE_INSENSITIVE);
				Matcher m = p.matcher(newWord);
				if (m.lookingAt()) {
					String pl = m.group(1).toLowerCase();
					if (getNumber(pl).equals("p")) {

						count++;
					}
					if (count >= 1) {
						return bPOS;
					}
				}
			}
		}
		return null;
	}

	/**
	 * This method corrects the pos of the word from N to M (establish newPOS)
	 * 
	 * @param newWord
	 * @param oldPOS
	 * @param pos
	 * @param role
	 * @param increment
	 * @return
	 */
	public int changePOS(String newWord, String oldPOS, String newPOS,
			String role, int increment) {
		oldPOS = oldPOS.toLowerCase();
		newPOS = newPOS.toLowerCase();

		String modifier = "";
		String tag = "";
		String sentence = null;
		int sign = 0;

		// case 1: oldPOS is "s" AND newPOS is "m"
		if (oldPOS.matches("^.*s.*$") && newPOS.matches("^.*m.*$")) {
			discount(newWord, oldPOS, newPOS, "all");
			sign += markKnown(newWord, "m", "", "modifiers", increment);
			for (int i = 0; i < this.sentenceTable.size(); i++) {
				Sentence sent = this.sentenceTable.get(i);
				if (sent.getTag().equals(newWord)) {
					modifier = sent.getModifier();
					tag = sent.getTag();
					sentence = sent.getSentence();
					tag = getParentSentenceTag(i);
					modifier = modifier + " " + newWord;
					modifier.replaceAll("^\\s*", "");
					List<String> pair = getMTFromParentTag(tag);
					String m = pair.get(1);
					tag = pair.get(2);
					if (m.matches("^.*\\w.*$")) {
						modifier = modifier + " " + m;
					}
					tagSentWithMT(i, sentence, modifier, tag,
							"changePOS[n->m:parenttag]");
				}
			}
			// case 2: oldPOS is "s" AND newPOS is "b"
		} else if ((oldPOS.matches("^.*s.*$")) && (newPOS.matches("^.*b.*$"))) {
			int certaintyU = 0;

			// case 2.1: (newWord, oldPOS)
			WordPOSKey newOldKey = new WordPOSKey(newWord, oldPOS);
			if (this.wordPOSTable.containsKey(newOldKey)) {
				WordPOSValue v = this.wordPOSTable.get(newOldKey);
				certaintyU = v.getCertaintyU();
				certaintyU += increment;
				discount(newWord, oldPOS, newPOS, "all");
			}

			// case 2.2: (newWord, newPOS)
			WordPOSKey newNewKey = new WordPOSKey(newWord, newPOS);
			if (!this.wordPOSTable.containsKey(newOldKey)) {
				this.wordPOSTable.put(newNewKey, new WordPOSValue(role,
						certaintyU, 0, "", ""));
			}
			sign++;

			// for all sentences tagged with (newWord, "b"), re tag them
			for (int i = 0; i < this.sentenceTable.size(); i++) {
				Sentence sent = this.sentenceTable.get(i);
				if (sent.getTag().equals(newWord)) {
					int sentID = i;
					String s = sent.getSentence();
					this.tagSentWithMT(sentID, s, "", "NULL",
							"changePOS[s->b: reset to NULL]");
				}
			}
		}
		// case 3: oldPOS is "b" AND newPOS is "s"
		else if (oldPOS.matches("^.*b.*$") && newPOS.matches("^.*s.*$")) {
			int certaintyU = 0;

			// case 3.1: (newWord, oldPOS)
			WordPOSKey newOldKey = new WordPOSKey(newWord, oldPOS);
			if (this.wordPOSTable.containsKey(newOldKey)) {
				WordPOSValue v = this.wordPOSTable.get(newOldKey);
				certaintyU = v.getCertaintyU();
				certaintyU += increment;
				discount(newWord, oldPOS, newPOS, "all");
			}

			// case 3.2: (newWord, newPOS)
			WordPOSKey newNewKey = new WordPOSKey(newWord, newPOS);
			if (!this.wordPOSTable.containsKey(newOldKey)) {
				this.wordPOSTable.put(newNewKey, new WordPOSValue(role,
						certaintyU, 0, "", ""));
			}
			sign++;
		}

		int sum_certaintyU = 0;
		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter1 = this.wordPOSTable
				.entrySet().iterator();
		while (iter1.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> e = iter1.next();
			if (e.getKey().getWord().equals(newWord)) {
				sum_certaintyU += e.getValue().getCertaintyU();
			}
		}
		if (sum_certaintyU > 0) {
			Iterator<Map.Entry<WordPOSKey, WordPOSValue>> iter2 = this.wordPOSTable
					.entrySet().iterator();
			while (iter2.hasNext()) {
				Map.Entry<WordPOSKey, WordPOSValue> e = iter2.next();
				if (e.getKey().getWord().equals(newWord)) {
					e.getValue().setCertiantyL(sum_certaintyU);
				}
			}
		}

		return sign;
	}

	/**
	 * 
	 * @param sentID
	 * @param sentence
	 * @param modifier
	 * @param tag
	 * @param label
	 */
	public void tagSentWithMT(int sentID, String sentence, String modifier,
			String tag, String label) {

		/**
		 * 1. Do some preprocessing of modifier and tag 
		 * 1. Remove -ly words 
		 * 1. Update modifier and tag of sentence sentID in sentenceTable
		 */

		modifier.replaceAll("<\\S+?>", "");
		tag.replaceAll("<\\S+?>", "");

		// remove stop and forbidden words from beginning
		modifier = this.removeAll(modifier, "\\s*\\b(" + this.STOP + "|"
				+ this.FORBIDDEN + "|\\w+ly)$");
		tag = this.removeAll(tag, "\\s*\\b(" + this.STOP + "|" + this.FORBIDDEN
				+ "|\\w+ly)$");

		// remove stop and forbidden words from ending
		modifier = this.removeAll(modifier, "\\s*\\b(" + this.STOP + "|"
				+ this.FORBIDDEN + "|\\w+ly)$");
		tag = this.removeAll(tag, "\\s*\\b(" + this.STOP + "|" + this.FORBIDDEN
				+ "|\\w+ly)$");

		// remove all pronoun words
		modifier = this.removeAll(modifier, "\\b(" + this.PRONOUN + ")\\b");

		Pattern p = Pattern.compile("^(\\w+ly)\\s*(.*)$");
		Matcher m = p.matcher(modifier);
		while (m.lookingAt()) {
			String ly = m.group(1);
			String rest = m.group(2);
			WordPOSKey wp = new WordPOSKey(ly, "b");
			if (this.wordPOSTable.containsKey(wp)) {
				modifier = rest;
				m = p.matcher(modifier);
			} else {
				break;
			}
		}

		modifier = this.removeAll(modifier, "(^\\s*|\\s*$)");
		tag = this.removeAll(tag, "(^\\s*|\\s*$)");

		if (tag != null) {
			if (tag.length() > this.tagLength) {
				tag = tag.substring(0, this.tagLength);
			}
		}

		for (int i = 0; i < this.sentenceTable.size(); i++) {
			Sentence sent = this.sentenceTable.get(i);
		}

		Sentence sent = this.sentenceTable.get(sentID);
		sent.setTag(tag);
		sent.setModifier(modifier);
	}

	/**
	 * 
	 * @param tag
	 * @return
	 */
	public List<String> getMTFromParentTag(String tag) {
		String modifier = "";
		String newTag = "";

		Pattern p = Pattern.compile("^\\[(\\w+)\\s+(\\w+)\\]$");
		Matcher m = p.matcher(tag);
		if (m.lookingAt()) {
			modifier = m.group(1);
			newTag = m.group(2);
		} else {
			p = Pattern.compile("^(\\w+)\\s+(\\w+)$");
			m = p.matcher(tag);
			if (m.lookingAt()) {
				modifier = m.group(1);
				newTag = m.group(2);
			}

		}
		List<String> pair = new ArrayList<String>();
		pair.add(modifier);
		pair.add(newTag);

		return pair;
	}

	/**
	 * Find the tag of the sentence of which this sentid (clause) is a part of
	 * 
	 * @param sentID
	 * @return a tag
	 */
	public String getParentSentenceTag(int sentID) {
		/**
		 * 1. Get the originalsent of sentence sentID
		 * 1. Case 1: the originalsent of $sentence sentID starts with a [a-z\d]
		 *     1.1 select modifier and tag from sentenceTable where
		 *             tag is not "ignore" OR tag is null
		 *             AND originalsent COLLATE utf8_bin regexp '^[A-Z].*' or originalsent rlike ': *\$'
		 *             AND id < sentID
		 *     1.1 take the tag of the first sentence (with smallest id), get its modifier and tag
		 *     1.1 if modifier match \w, tag = modifier + space + tag
		 *     1.1 remove [ and ] from tag
		 * 1. if tag matches \w return [+tag+], else return [parenttag] 
		 */

		String tag = "";

		String originalSent = this.sentenceTable.get(sentID)
				.getOriginalSentence();
		if (originalSent.matches("^\\s*([a-z]|\\d).*$")) {
			for (int i = 0; i < this.sentenceTable.size(); i++) {
				Sentence sent = this.sentenceTable.get(i);
				tag = sent.getTag();
				if (((!tag.equals("ignore")) || (tag == null))
						&& ((originalSent.matches("^[A-Z].*$")) || (originalSent.matches("^.*:\\s*\\$"))) 
						&& (i < sentID)) {
					String modifier = sent.getModifier();
					if (modifier.matches("^.*\\w.*$")) {
						tag = modifier + " " + tag;
						tag.replaceAll("[\\[\\]]", "");
					}
					break;
				}
			}
		}

		return tag.matches("^.*\\w.*$") ? "[parenttag]" : "[" + tag + "]";
	}

	/**
	 * Discount existing pos, but do not establish $suggestedpos
	 * 
	 * @param newWord
	 * @param oldPOS
	 * @param newPOS
	 * @param mode
	 *            "byone" - reduce certainty 1 by 1. 
	 *            "all" - remove this POS
	 */
	public void discount(String newWord, String oldPOS, String newPOS,
			String mode) {
		
		/**
		 * 1. Find the flag of newWord in unknownWords table
		 * 1. Select all words from unknownWords table who have the same flag (including newWord)
		 * 1. From wordPOS table, select certaintyU of the (word, oldPOS) where word is in the words list
		 *     For each of them
		 *     1.1 Case 1: certaintyu less than 1, AND mode is "all"
		 *         1.1.1 Delete the entry from wordpos table
		 *         1.1.1 Update unknownwords
		 *             1.1.1.1 Case 1: the pos is "s" or "p"
		 *                 Delete all entries contains word from singularplural table as well
		 *         1.1.1 Insert (word, oldpos, newpos) into discounted table
		 */

		String flag = this.unknownWordTable.get(newWord);
		Iterator<Map.Entry<String, String>> iter = this.unknownWordTable
				.entrySet().iterator();
		while (iter.hasNext()) {
			Map.Entry<String, String> e = iter.next();
			if (e.getValue().equals(flag)) {
				String word = e.getKey();
				WordPOSKey key = new WordPOSKey(word, oldPOS);
				WordPOSValue value = this.wordPOSTable.get(key);
				int cU = value.getCertaintyU();
				if (cU < 1 && mode.equals("all")) {
					this.wordPOSTable.remove(key);
					this.updateUnknownWords(word, "unknown");
					if (oldPOS.matches("^.*[sp].*$")) {
						// list of entries to be deleted
						ArrayList<SingularPluralPair> delList = new ArrayList<SingularPluralPair>();

						// find entries to be deleted, put them into delList
						Iterator<SingularPluralPair> iterSPTable = this.singularPluralTable
								.iterator();
						while (iterSPTable.hasNext()) {
							SingularPluralPair spp = iterSPTable.next();
							if (spp.getSingular().equals(word)
									|| spp.getPlural().equals(word)) {
								delList.add(spp);
							}
						}

						// delete all entries in delList from
						// singularPluralTable
						for (int i = 0; i < delList.size(); i++) {
							this.singularPluralTable.remove(delList.get(i));
						}
					}

					DiscountedKey dKey = new DiscountedKey(word, oldPOS);
					this.discountedTable.put(dKey, newPOS);
				}
			}
		}
	}

	/**
	 * Given a new role, and the old role, of a word, decide the right role to
	 * return
	 * 
	 * @param oldRole
	 * @param role
	 * @return
	 */
	public String mergeRole(String oldRole, String role) {
	String role1 = oldRole;
		String role2 = role;
		
		// if old role is "*", return the new role
		if (role1.equals("*")) {
			return role2;
		}
		// if the new role is "*", return the old rule
		else if (role2.equals("*")) {
			return role1;
		}
		
		// if the old role is empty, return the new role
		if (role1.equals("")) {
			return role2;
		}
		// if the new role is empty, return the old role
		else if (role2.equals("")) {
			return role1;
		}
		// if the old role is not same as the new role, return "+"
		else if (!role1.equals(role2)) {
			return "+";
		}
		// if none of above apply, return the old role by default
		else {
			return role1;
		}
	}

	
	/**
	 * Take a new word, insert it into modifer table, or update its count in
	 * modifer table if the word already exist
	 * 
	 * @param newWord
	 * @param increment
	 * @return if anything changed in modifer table, return true; otherwise
	 *         return false
	 */
	public int addModifier(String newWord, int increment) {
		int isUpdate = 0;

		if ((newWord.matches("(" + this.STOP + "|^.*\\w+ly$)"))
				|| (!(newWord.matches("^.*\\w.*$")))) {
			return isUpdate;
		}

		if (this.modifierTable.containsKey(newWord)) {
			int count = this.modifierTable.get(newWord).getCount();
			count = count + increment;
			this.modifierTable.get(newWord).setCount(count);
			//isUpdate = 1;
		} else {
			this.modifierTable.put(newWord, new ModifierTableValue(1, false));
			isUpdate = 1;
		}

		return isUpdate;
	}

	/**
	 * Helper of method updateTable
	 * @param w
	 * @return
	 */
	public String getNumber(String word) {
		String number = checkWN(word, "number");
		String rt = "";

		rt = getNumberHelper1(number);
		if (rt != null) {
			return rt;
		}

		rt = getNumberHelper2(word);
		if (rt != null) {
			return rt;
		} else {
			return "s";
		}
	}

	/**
	 * First Helper of method getNumber
	 * 
	 * @param number
	 * @return if match return the right number, otherwise return null means not
	 *         match
	 */
	public String getNumberHelper1(String number) {
		if (number.matches("^.*[sp].*$")) {
			return number;
		}
		if (number.matches("^.*x.*$")) {
			return "";
		}
		return null;
	}

	/**
	 * Second Helper of method getNumber
	 * 
	 * @param word
	 * @return if match return the right number, otherwise return null means not
	 *         match
	 */
	public String getNumberHelper2(String word) {
		// Calyculi => 1. Calyculus, pappi => pappus
		if (word.matches("^.*i$")) {
			return "p";
		}
		if (word.matches("^.*ss$")) {
			return "s";
		}
		if (word.matches("^.*ia$")) {
			return "p";
		}
		if (word.matches("^.*[it]um$")) {
			return "s";
		}
		if (word.matches("^.*ae$")) {
			return "p";
		}
		if (word.matches("^.*ous$")) {
			return "";
		}
		// this case only handle three words: as, is, us
		if (word.matches("^[aiu]s$")) {
			return "";
		}
		if (word.matches("^.*us$")) {
			return "s";
		}
		if (word.matches("^.*es$") || word.matches("^.*s$")) {
			return "p";
		}
		if (word.matches("^.*ate$")) {
			return "";
		}
		return null;
	}

	/**
	 * 1) Check wordnet to gether information about a word 
	 * 2) Save checked words in three hash tables, singularRecords (singular), numberRecords (number), and POSRecords (pos), respectively
	 * 
	 * @param word
	 *            The word to check
	 * @param mode
	 *            The mode can be "signular", "number", "pos"
	 * @return 1) mode "singular": if a plural noun, return its singular form, otherwise, return itself. 
	 *         2) mode "number": if a noun, return "p" [plural] or "s"[singular], else if not in WN "", otherwise "x".
	 *         3) mode "pos": return n [p,s], v, a, r, "" (not in WN).
	 */
	public String checkWN(String word, String mode) {
		
		/**
		 * 0.0 If the word contains nothing but non-word characters, such as <>, return empty
		 * 0.1 Check singularRecordsprevious records
		 * 0.2 Special cases
		 * 1   Word not in WordNet
		 * 	1.1
		 * 	1.2
		 * 	1.3
		 * 2.  Word in WordNet
		 * 	2.1 mode is singular or number
		 * 		2.1.1
		 * 		2.1.2
		 *  2.2 mode is pos
		 */
		
		//this.myWN.getMostLikleyPOS(word);
		
		// If the word contains nothing but non-word characters, such as <>, return empty
		word = word.replaceAll("\\W", "");
		if (word.equals("")) {
			return "";
		}
		
		// Check previous records
		// singular case
		String singular = "";
		if (mode.equals("singular")) {
			singular = this.singularRecords.get(word);
		}
		if (singular != null) {
			if (singular.matches("^.*\\w.*$")) {
				return singular;
			}
		}

		// number case
		String number = "";
		if (mode.equals("number")) {
			number = this.numberRecords.get(word);
		}
		if (number != null) {
			if (number.matches("^.*\\w.*$")) {
				return number;
			}
		}

		// pos case
		String pos = "";
		if (mode.equals("pos")) {
			pos = this.POSRecords.get(word);
		}
		if (pos != null) {
			if (pos.matches("^.*\\w.*$")) {
				return pos;
			}
		}
	
		// Case 0: special cases
		if (word.equals("teeth")) {
			this.numberRecords.put("teeth", "p");
			this.singularRecords.put("teeth", "tooth");
			return mode.equals("singular")?"tooth":"p";
		}
		
		if (word.equals("tooth")) {
			this.numberRecords.put("tooth", "s");
			this.singularRecords.put("tooth", "tooth");
			return mode.equals("singular")?"tooth":"s";
		}

		if (word.equals("NUM")) {
			return mode.equals("singular")?"NUM":"s";
		}

		if (word.equals("or")) {
			return mode.equals("singular")?"or":"";
		}

		if (word.equals("and")) {
			return mode.equals("singular")?"and":"";
		}

		// concentrically
		if (word.matches("^.*[a-z]{3,}ly$")) {
			if (mode.equals("singular")) {
				return word;	
			}
			if (mode.equals("number")) {
				return "";	
			}
			if (mode.equals("pos")) {
				return "r";	
			}
		}
		
		// otherwise, call WordNet
		// Case 1
		if (!this.myWN.contains(word)) {// word not in WN
			boolean f = this.myWN.contains(word);
			this.POSRecords.put(word, "");
			String wordCopy = word;
			word = word.replaceAll("ed$", "");
			// Case 1.1
			if (!word.equals(wordCopy)) {
				if (this.myWN.contains(word)) {
					// Case 1.1.1-1.1.3
					if (mode.equals("singular")) {
						return word;
					}
					if (mode.equals("number")) {
						return "";
					}
					if (mode.equals("pos")) {
						return "a";
					}
				}
			}
			
			word = wordCopy;
			word = word.replace("^(" + this.PREFIX + ")+", "");
			// Case 1.2
			if (word.equals(wordCopy)) {
				return mode.equals("singular") ? word : "";
			} 
			// Case 1.3
			else {
				if (!this.myWN.contains(word)) {
					return mode.equals("singular") ? wordCopy : "";
				}
			}
		}
		else { if (mode.equals("singular") || mode.equals("number")) {
			// Case 2.1.1: not a noun
			if (!this.myWN.isNoun(word)) {
				return mode.equals("singular") ? word : "x";
			}
			List<String> stemList = myWN.getSingulars(word);
			int maxLength = 100;
			String sWord = "";
			for (int i=0;i<stemList.size();i++) {
				String stem = stemList.get(i);
				if (stem.length()<maxLength) {
					maxLength = stem.length();
					sWord = stem;
				}
			}
			this.singularRecords.put(word, sWord);
			// Case 2.1.2: singular
			if (sWord.equals(word)) {
				this.numberRecords.put(word, "s");
				return mode.equals("singular")?sWord:"s";
			}
			// Case 2.1.3: pluarl
			else {
				this.numberRecords.put(word, "p");
				return mode.equals("singular")?sWord:"p";
			}		
		}
		// Case 2.2
		else if (mode.equals("pos")) {
			pos = "";
			if (this.myWN.isNoun(word)){
				pos = pos+"n";
			}
			if (this.myWN.isVerb(word)){
				pos = pos+"v";
			}
			if (this.myWN.isAdjective(word)){
				pos = pos+"a";
			}
			if (this.myWN.isAdverb(word)){
				pos = pos+"r";
			}
			this.POSRecords.put(word, pos);
			if ((this.myWN.isNoun(word)) 
					&& (this.myWN.isVerb(word))
					&& (word.matches("^.*(ed|ing)$"))) {
				pos.replaceAll("n", "");
			}
			this.POSRecords.put(word, pos);
			return pos;
			}
		}
		return "";
	}

	/**
	 * Helper of method updateTable: process word
	 * 
	 * @param w
	 * @return
	 */

	public String processWord(String word) {
		//$word =~ s#<\S+?>##g; #remove tag from the word
		//$word =~ s#\s+$##;
		//$word =~ s#^\s*##;
		
		word = word.replaceAll("<\\S+?>", "");
		word = word.replaceAll("\\s+$", "");
		word = word.replaceAll("^\\s*", "");
		
		return word;
	}
	
	
	public String removeAll(String word, String regex) {
		String newWord = word.replaceAll(regex, ""); 
		return newWord;
	}
	public String getStopWords(){
		return this.STOP;
	}
	public String getForbiddenWords(){
		return this.FORBIDDEN;
	}	
	public String getPronounWords(){
		return this.PRONOUN;
	}
	
	
	// ---------------TEST Helper function----------------
	public void printWordPOSTable() {
		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> entries = this.wordPOSTable
				.entrySet().iterator();
		while (entries.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> entry = entries.next();
			System.out.println(entry.getKey().getWord() + ", "
					+ entry.getKey().getPOS() + ", "
					+ entry.getValue().getRole() + ", "
					+ entry.getValue().getCertaintyU() + ", "
					+ entry.getValue().getCertaintyL() + ", "
					+ entry.getValue().getSavedFlag() + ", "
					+ entry.getValue().getSavedID());
		}
	}
	

}
package semanticMarkup.ling.learn;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import opennlp.tools.sentdetect.SentenceDetectorME;
import opennlp.tools.sentdetect.SentenceModel;
import opennlp.tools.tokenize.Tokenizer;
import opennlp.tools.tokenize.TokenizerME;
import opennlp.tools.tokenize.TokenizerModel;
import opennlp.tools.util.InvalidFormatException;

import semanticMarkup.core.Treatment;
import semanticMarkup.knowledge.Stemmer;
import semanticMarkup.knowledge.lib.WordNetAPI;

public class UnsupervisedClauseMarkup implements ITerminologyLearner {	
	// Date holder
	public DataHolder myDataHolder;
	
	// Configuration
		private Configuration myConfiguration;
		
		// Utility
		private Utility myUtility;

	// Learner
	private Learner myLearner;
	
	

	// unused variables
	// directory of /descriptions folder
	private String desDir = "";
	// directory of /characters folder
	private String chrDir = "";
	// prefix for all tables generated by this program
	private String prefix = "";
	// default general tag
	private String defaultGeneralTag = "general";
	// knowledge base
	private String knlgBase = "phenoscape";

	private int DECISIONID = 0;

	private Map<String, String> numberRecords = new HashMap<String, String>(); // word->(p|s)
	private Map<String, String> singularRecords = new HashMap<String, String>();// word->singular
	private Map<String, String> POSRecords = new HashMap<String, String>(); // word->POSs
	// private Map<String, String> POSRecordsRECORDS = new HashMap<String,
	// String>();
	private String NEWDESCRIPTION = ""; // record the index of sentences that
										// ends a description

	private Hashtable<String, String> PLURALS = new Hashtable<String, String>();

	private String TAGS = "";

	// grouped #may contain q but not the last m, unless it is followed by a p
	private String mptn = "((?:[mbq][,&]*)*(?:m|b|q(?=[pon])))";
	// grouped #must present, no q allowed
	private String nptn = "((?:[nop][,&]*)*[nop])";
	// grouped #when following a p, a b could be a q
	private String bptn = "([,;:\\\\.]*\\$|,*[bm]|(?<=[pon]),*q)";
	private String SEGANDORPTN = "(?:" + mptn + nptn + ")";
	private String ANDORPTN = "^(?:" + SEGANDORPTN + "[,&]+)*" + SEGANDORPTN
			+ bptn;

	/**
	 * Constructor of UnsupervisedClauseMarkup class. Create a new
	 * UnsupervisedClauseMarkup object.
	 * 
	 * @param learningMode
	 *            learning mode. There two legal values, "adj" and "plain"
	 * @param wordnetDir
	 *            directory of WordNet dictionary
	 */
	public UnsupervisedClauseMarkup(String learningMode, String wordnetDir) {
		this.chrDir = desDir.replaceAll("descriptions.*", "characters/");
		// Get DataHolder
		// this.myDataHolder = null;// 
		
		this.myConfiguration = new Configuration();
		this.myUtility = new Utility(myConfiguration);
		this.myDataHolder = new DataHolder(this.myUtility);
		myLearner = new Learner(this.myConfiguration, this.myUtility);
		
	}

	public void learn(List<Treatment> treatments) {
		this.myDataHolder = this.myLearner.Learn(treatments);
	}

	// interface metods
	public Map<Treatment, List<String>> getSentences() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getSentences\n");
		return null;
	}

	public Map<Treatment, List<String>> getSentencesForOrganStateMarker() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getSentencesForOrganStateMarker\n");
		return null;
	}

	public List<String> getAdjNouns() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		Set<String> myAdjNounSet = new HashSet<String>();

		Iterator<Sentence> iter = this.myDataHolder.getSentenceHolder()
				.iterator();

		while (iter.hasNext()) {
			Sentence sentence = iter.next();
			String modifier = sentence.getModifier();
			String tag = sentence.getTag();
			if (tag.matches("^\\[.*$")) {
				modifier = modifier.replaceAll("\\[.*?\\]", "").trim();
				myAdjNounSet.add(modifier);
			}
		}

		List<String> myAdjNouns = new ArrayList<String>();
		myAdjNouns.addAll(myAdjNounSet);

		return myAdjNouns;
	}

	public Map<String, String> getAdjNounSent() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		Map<String, String> myAdjNounSent = new HashMap<String, String>();

		// collect senteces that need adj-nn disambiguation
		Iterator<Sentence> iter = this.myDataHolder.getSentenceHolder()
				.iterator();

		while (iter.hasNext()) {
			Sentence sentence = iter.next();
			String modifier = sentence.getModifier();
			String tag = sentence.getTag();
			if ((!(modifier.equals(""))) && (tag.matches("^\\[.*$"))) {
				modifier = modifier.replaceAll("\\[.*?\\]", "").trim();
				myAdjNounSent.put(tag, modifier);
			}
		}

		return myAdjNounSent;
	}

	public Set<String> getBracketTags() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getAdjNounsSent\n");
		return null;
	}

	public Set<String> getWordRoleTags() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getSentenceTags\n");
		return null;
	}

	public Map<String, Set<String>> getWordToSources() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		Map<String, Set<String>> myWordToSources = new HashMap<String, Set<String>>();

		Iterator<Sentence> iter = this.myDataHolder.getSentenceHolder()
				.iterator();

		TokenizerME myTokenizer = this.myUtility.getTokenizer();
		while (iter.hasNext()) {
			Sentence sentenceElement = iter.next();
			String source = sentenceElement.getSource();
			String sentence = sentenceElement.getSentence();			
			String[] words = myTokenizer.tokenize(sentence);
			for (int i = 0; i < words.length; i++) {
				String word = words[i];
				if (!myWordToSources.containsKey(word))
					myWordToSources.put(word, new HashSet<String>());
				myWordToSources.get(word).add(source);
			}
		}

		return myWordToSources;
	}

	public Map<String, Set<String>> getRoleToWords() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getRoleToWords\n");
		return null;

	}

	public Map<String, Set<String>> getWordsToRoles() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getWordsToRoles\n");
		return null;
	}

	public Map<String, String> getHeuristicNouns() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		return this.myDataHolder.getHeuristicNounTable();
	}

	public Map<Treatment, List<String>> getSentenceTags() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getTermCategories\n");
		return null;
	}

	public Map<String, Set<String>> getTermCategories() {
		if (this.myDataHolder == null) {
			return null;
		}
		
		System.out.println("Method: getTermCategories\n");
		return null;
	}

	// ---------------CLASS Helper function----------------

	public boolean testWN(String word) {
		try {
			WordNetAPI myWN = new WordNetAPI(
					"/Users/nescent/Phenoscape/WordNet-3.0/dict", false);

			if (myWN.isNoun(word)) {
				System.out.println(word + " is a noun");
			}
			if (myWN.isVerb(word)) {
				System.out.println(word + " is a verb");
			}
			if (myWN.isAdjective(word)) {
				System.out.println(word + " is a adj");
			}
			if (myWN.isAdverb(word)) {
				System.out.println(word + " is a adv");
			}

			return true;
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}
	}

	// ---------------TEST Helper function----------------
	public void printWordPOSTable() {
		Map<WordPOSKey, WordPOSValue> myWordPOSHolder = this.myDataHolder.getWordPOSHolder();
		Iterator<Map.Entry<WordPOSKey, WordPOSValue>> entries = myWordPOSHolder.entrySet().iterator();
		while (entries.hasNext()) {
			Map.Entry<WordPOSKey, WordPOSValue> entry = entries.next();
			System.out.println(entry.getKey().getWord() + ", "
					+ entry.getKey().getPOS() + ", "
					+ entry.getValue().getRole() + ", "
					+ entry.getValue().getCertaintyU() + ", "
					+ entry.getValue().getCertaintyL() + ", "
					+ entry.getValue().getSavedFlag() + ", "
					+ entry.getValue().getSavedID());
		}
	}

	public DataHolder getDataHolder() {
		return this.myDataHolder;
	}

}